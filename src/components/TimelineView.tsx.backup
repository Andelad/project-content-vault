import React, { useState, useCallback, useMemo } from 'react';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { TooltipProvider } from './ui/tooltip';
import { Card } from './ui/card';
import { ToggleGroup, ToggleGroupItem } from './ui/toggle-group';
import { ChevronLeft, ChevronRight, MapPin, CalendarSearch, Folders, Hash, Circle, PanelLeft } from 'lucide-react';
import { useProjectContext } from '../contexts/ProjectContext';
import { useTimelineContext } from '../contexts/TimelineContext';
import { usePlannerContext } from '../contexts/PlannerContext';
import { useSettingsContext } from '../contexts/SettingsContext';
import { expandHolidayDates, TimelineViewportService } from '@/services';
import { useTimelineData } from '../hooks/useTimelineData';
import { useDynamicViewportDays } from '../hooks/useDynamicViewportDays';
import { calculateDaysDelta, createSmoothAnimation, debounce, throttle } from '@/lib/dragUtils';
import { TIMELINE_CONSTANTS } from '@/constants';
import { performanceMonitor } from '@/lib/performanceUtils';
import { checkProjectOverlap, adjustProjectDatesForDrag } from '@/lib/projectOverlapUtils';
import { throttledDragUpdate, clearDragQueue } from '@/lib/dragPerformance';

// Import timeline components
import { TimelineHeader } from './timeline/TimelineHeader';
import { TimelineSidebar } from './timeline/TimelineSidebar';
import { TimelineDateHeaders } from './timeline/TimelineDateHeaders';
import { TimelineBar } from './timeline/TimelineBar';
import { TimelineColumnMarkers } from './timeline/TimelineColumnMarkers';
import { TimelineScrollbar } from './timeline/TimelineScrollbar';
import { HoverableTimelineScrollbar } from './timeline/HoverableTimelineScrollbar';
import { TimelineAddProjectRow, AddHolidayRow } from './timeline/AddProjectRow';
import { SmartHoverAddProjectBar } from './projects/SmartHoverAddProjectBar';
import { TimelineControls } from './timeline/TimelineControls';
import { PerformanceStatus } from './PerformanceStatus';
import { AppPageLayout } from './layouts/AppPageLayout';
import { TimelineHolidayOverlay } from './timeline/TimelineHolidayOverlay';
import { TimelineAvailabilityContent } from './timeline/TimelineAvailabilityContent';
import { TimelineInteractions } from './timeline/TimelineInteractions';
import { TimelineProjectRenderer } from './timeline/TimelineProjectRenderer';

export function TimelineView() {
  // Get data from specific contexts
  const { 
    projects, 
    groups, 
    rows, 
    selectedProjectId, 
    milestones,
    updateProject, 
    setSelectedProjectId, 
    addProject, 
    updateMilestone,
    setCreatingNewProject,
    showMilestoneSuccessToast,
    showProjectSuccessToast
  } = useProjectContext();

  const { 
    currentDate, 
    timelineMode,
    collapsedGroups,
    setTimelineMode,
    setCurrentDate 
  } = useTimelineContext();

  const { 
    holidays,
    updateHoliday
  } = usePlannerContext();

  const { 
    settings 
  } = useSettingsContext();
  
  // Debug: Log the data structures  
  console.log('🔍 TimelineView - Available rows:', rows.length);
  console.log('🔍 TimelineView - Available groups:', groups.length);
  console.log('🔍 TimelineView - Available projects:', projects.length);
  
  // Check for orphaned projects (projects without proper rowId or groupId)
  const orphanedProjects = projects.filter(p => !p.rowId || !p.groupId);
  if (orphanedProjects.length > 0) {
    console.warn('� ORPHANED PROJECTS (missing rowId or groupId):', orphanedProjects.map(p => ({ 
      id: p.id, 
      name: p.name, 
      rowId: p.rowId, 
      groupId: p.groupId 
    })));
  }
  
  // Check for projects that have rowId/groupId but don't match existing rows
  const mismatchedProjects = projects.filter(p => {
    if (!p.rowId || !p.groupId) return false;
    const matchingRow = rows.find(r => r.id === p.rowId && r.groupId === p.groupId);
    return !matchingRow;
  });
  if (mismatchedProjects.length > 0) {
    console.warn('🚨 MISMATCHED PROJECTS (invalid rowId/groupId):', mismatchedProjects.map(p => ({ 
      id: p.id, 
      name: p.name, 
      rowId: p.rowId, 
      groupId: p.groupId 
    })));
  }
  
  // Auto-fix orphaned projects - assign them to the first available row in their group
  React.useEffect(() => {
    const orphanedProjects = projects.filter(p => !p.rowId || !p.groupId);
    
    if (orphanedProjects.length > 0 && groups.length > 0 && rows.length > 0) {
      console.log('🔧 Auto-fixing orphaned projects...');
      
      orphanedProjects.forEach(project => {
        // If project has no groupId, assign to first available group
        const targetGroupId = project.groupId || groups[0].id;
        
        // Find first row in this group
        const groupRows = rows.filter(r => r.groupId === targetGroupId);
        const targetRowId = project.rowId || (groupRows.length > 0 ? groupRows[0].id : null);
        
        if (targetRowId && (!project.rowId || !project.groupId)) {
          console.log(`🔧 Auto-fixing project ${project.name}: assigning to groupId=${targetGroupId}, rowId=${targetRowId}`);
          updateProject(project.id, { 
            groupId: targetGroupId,
            rowId: targetRowId
          }, { silent: true });
        }
      });
    }
  }, [projects, groups, rows, updateProject]);
  
  // Timeline state management
  const [viewportStart, setViewportStart] = useState(() => {
    const start = new Date(currentDate);
    start.setDate(1); // Start at beginning of month
    start.setHours(0, 0, 0, 0); // Normalize time component
    return start;
  });
  
  // Protected viewport setter that respects scrollbar blocking using service
  const protectedSetViewportStart = useCallback((date: Date) => {
    const blockingState = TimelineViewportService.checkViewportBlocking();
    if (blockingState.isBlocked) {
      console.log(`🚫 TimelineView blocked from updating viewport - ${blockingState.reason}`);
      return;
    }
    setViewportStart(date);
  }, []);
  
  const [collapsed, setCollapsed] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [dragState, setDragState] = useState<any>(null);
  const [isAnimating, setIsAnimating] = useState(false);
  const [isDatePickerOpen, setIsDatePickerOpen] = useState(false);
  const [projectSearchQuery, setProjectSearchQuery] = useState('');
  const [availabilityDisplayMode, setAvailabilityDisplayMode] = useState<'circles' | 'numbers'>('circles');

  // Auto-scroll state for drag operations
  const [autoScrollState, setAutoScrollState] = useState<{
    isScrolling: boolean;
    direction: 'left' | 'right' | null;
    intervalId: NodeJS.Timeout | null;
  }>({
    isScrolling: false,
    direction: null,
    intervalId: null
  });

  // Get dynamic viewport days based on available width
  const VIEWPORT_DAYS = useDynamicViewportDays(collapsed, timelineMode);

  // Get timeline data using your existing hook
  const { dates, viewportEnd, filteredProjects, mode, actualViewportStart } = useTimelineData(projects, viewportStart, VIEWPORT_DAYS, timelineMode, collapsed);

  // Expand holiday ranges into individual Date objects for fast lookup by the markers
  const holidayDates = useMemo(() => {
    const holidaysWithName = holidays.map(h => ({ ...h, name: h.title || 'Holiday' }));
    return expandHolidayDates(holidaysWithName);
  }, [holidays]);

  // Debug performance logging using service
  const performanceMetrics = useMemo(() => {
    return TimelineViewportService.calculateViewportPerformanceMetrics({
      timelineMode,
      daysCount: dates.length,
      projectsCount: filteredProjects.length
    });
  }, [timelineMode, dates.length, filteredProjects.length]);

  console.log(`🚀 Timeline performance:`, {
    mode: timelineMode,
    days: dates.length,
    projects: filteredProjects.length,
    ...performanceMetrics
  });

  // Memoize date range formatting using service
  const dateRangeText = useMemo(() => {
    return TimelineViewportService.formatDateRange(actualViewportStart, viewportEnd);
  }, [actualViewportStart, viewportEnd]);

  // Navigation handlers with smooth scrolling using service
  const handleNavigate = useCallback((direction: 'prev' | 'next') => {
    if (isAnimating) return;
    
    const targetViewport = TimelineViewportService.calculateNavigationTarget({
      currentViewportStart: viewportStart,
      viewportDays: VIEWPORT_DAYS,
      direction,
      timelineMode
    });
    
    const animationDuration = TimelineViewportService.calculateAnimationDuration(
      viewportStart.getTime(),
      targetViewport.start.getTime(),
      timelineMode
    );
    
    setIsAnimating(true);
    createSmoothAnimation(
      viewportStart.getTime(),
      targetViewport.start.getTime(),
      animationDuration,
      (intermediateStart) => setViewportStart(intermediateStart),
      (targetStart) => {
        setViewportStart(targetStart);
        setCurrentDate(new Date(targetStart));
        setIsAnimating(false);
      }
    );
  }, [viewportStart, setCurrentDate, isAnimating, VIEWPORT_DAYS, timelineMode]);

  const handleGoToToday = useCallback(() => {
    if (isAnimating) return;
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const targetViewport = TimelineViewportService.calculateTodayTarget({
      selectedDate: today,
      currentViewportStart: viewportStart,
      viewportDays: VIEWPORT_DAYS,
      timelineMode
    });
    
    // Check if animation should be skipped
    if (TimelineViewportService.shouldSkipAnimation(viewportStart.getTime(), targetViewport.start.getTime())) {
      setViewportStart(targetViewport.start);
      setCurrentDate(today);
      return;
    }
    
    const animationDuration = TimelineViewportService.calculateAnimationDuration(
      viewportStart.getTime(),
      targetViewport.start.getTime(),
      timelineMode
    );
    
    setIsAnimating(true);
    createSmoothAnimation(
      viewportStart.getTime(),
      targetViewport.start.getTime(),
      animationDuration,
      (intermediateStart) => setViewportStart(intermediateStart),
      () => {
        setViewportStart(targetViewport.start);
        setCurrentDate(today);
        setIsAnimating(false);
      }
    );
  }, [viewportStart, setCurrentDate, isAnimating, VIEWPORT_DAYS, timelineMode]);

  const handleDateSelect = useCallback((selectedDate: Date | undefined) => {
    if (!selectedDate || isAnimating) return;
    
    // Normalize the selected date
    const normalizedDate = new Date(selectedDate);
    normalizedDate.setHours(0, 0, 0, 0);
    
    // Calculate target viewport start to center the selected date
    const targetViewportStart = new Date(normalizedDate);
    targetViewportStart.setDate(normalizedDate.getDate() - Math.floor(VIEWPORT_DAYS / 4));
    
    const currentStart = viewportStart.getTime();
    const targetStart = targetViewportStart.getTime();
    const daysDifference = Math.abs((targetStart - currentStart) / (24 * 60 * 60 * 1000));
    
    // Close the date picker
    setIsDatePickerOpen(false);
    
    if (daysDifference < 1) {
      setViewportStart(targetViewportStart);
      setCurrentDate(normalizedDate);
      return;
    }
    
    setIsAnimating(true);
    const animationDuration = Math.min(
      TIMELINE_CONSTANTS.SCROLL_ANIMATION_MAX_DURATION, 
      daysDifference * TIMELINE_CONSTANTS.SCROLL_ANIMATION_MS_PER_DAY
    );
    
    createSmoothAnimation(
      currentStart,
      targetStart,
      animationDuration,
      (intermediateStart) => setViewportStart(intermediateStart),
      () => {
        setViewportStart(targetViewportStart);
        setCurrentDate(normalizedDate);
        setIsAnimating(false);
      }
    );
  }, [viewportStart, setCurrentDate, isAnimating, VIEWPORT_DAYS]);

  const handleToggleCollapse = useCallback(() => {
    setCollapsed(prev => !prev);
  }, []);

  // Scroll to project functionality using service
  const scrollToProject = useCallback((project: any) => {
    if (isAnimating) return;
    
    const targetViewport = TimelineViewportService.calculateProjectScrollTarget({
      projectStartDate: new Date(project.startDate),
      currentViewportStart: viewportStart,
      timelineMode
    });
    
    // Check if animation should be skipped
    if (TimelineViewportService.shouldSkipAnimation(viewportStart.getTime(), targetViewport.start.getTime())) {
      setViewportStart(targetViewport.start);
      setCurrentDate(new Date(project.startDate));
      return;
    }
    
    const animationDuration = TimelineViewportService.calculateAnimationDuration(
      viewportStart.getTime(),
      targetViewport.start.getTime(),
      timelineMode
    );
    
    setIsAnimating(true);
    createSmoothAnimation(
      viewportStart.getTime(),
      targetViewport.start.getTime(),
      animationDuration,
      (intermediateStart) => setViewportStart(intermediateStart),
      () => {
        setViewportStart(targetViewport.start);
        setCurrentDate(new Date(project.startDate));
        setIsAnimating(false);
      }
    );
  }, [viewportStart, setCurrentDate, isAnimating, timelineMode]);

  // Auto-scroll functions for drag operations using service
  const startAutoScroll = useCallback((direction: 'left' | 'right') => {
    if (autoScrollState.isScrolling && autoScrollState.direction === direction) return;
    
    // Clear any existing auto-scroll
    if (autoScrollState.intervalId) {
      clearInterval(autoScrollState.intervalId);
    }
    
    const config = TimelineViewportService.calculateAutoScrollConfig(timelineMode);
    config.direction = direction;
    
    const intervalId = setInterval(() => {
      setViewportStart(prevStart => {
        // Check if viewport updates are blocked
        const blockingState = TimelineViewportService.checkViewportBlocking();
        if (blockingState.isBlocked) {
          console.log(`🚫 Auto-scroll blocked from updating viewport - ${blockingState.reason}`);
          return prevStart;
        }
        
        const newStart = TimelineViewportService.calculateAutoScrollPosition(
          prevStart, 
          direction, 
          config.scrollAmount
        );
        setCurrentDate(new Date(newStart));
        return newStart;
      });
    }, config.intervalMs);
    
    setAutoScrollState({
      isScrolling: true,
      direction,
      intervalId
    });
  }, [autoScrollState, timelineMode, setCurrentDate]);

  const stopAutoScroll = useCallback(() => {
    if (autoScrollState.intervalId) {
      clearInterval(autoScrollState.intervalId);
    }
    setAutoScrollState({
      isScrolling: false,
      direction: null,
      intervalId: null
    });
  }, [autoScrollState.intervalId]);

  const checkAutoScroll = useCallback((clientX: number) => {
    if (!isDragging) return;
    
    // Get the timeline content area bounds
    const timelineContent = document.querySelector('.timeline-content-area');
    if (!timelineContent) return;
    
    const rect = timelineContent.getBoundingClientRect();
    const trigger = TimelineViewportService.calculateAutoScrollTrigger({
      mouseX: clientX,
      timelineContentRect: rect
    });
    
    if (trigger.shouldScroll && trigger.direction) {
      startAutoScroll(trigger.direction);
    } else {
      stopAutoScroll();
    }
  }, [isDragging, startAutoScroll, stopAutoScroll]);

  // Clean up auto-scroll on unmount or when dragging stops
  React.useEffect(() => {
    if (!isDragging) {
      stopAutoScroll();
    }
  }, [isDragging, stopAutoScroll]);

  React.useEffect(() => {
    return () => {
      if (autoScrollState.intervalId) {
        clearInterval(autoScrollState.intervalId);
      }
    };
  }, [autoScrollState.intervalId]);

  // Mouse handlers for timeline bar interactions
  const handleMouseDown = useCallback((e: React.MouseEvent, projectId: string, action: string) => {
    // 🚫 PREVENT BROWSER DRAG-AND-DROP: Stop the globe/drag indicator
    e.preventDefault();
    e.stopPropagation();
    
    // DEBUG: Alert to confirm drag is starting
    console.log('🎯 DRAG START:', { projectId, action, clientX: e.clientX, clientY: e.clientY });
    
    const targetProject = projects.find(p => p.id === projectId);
    if (!targetProject) return;
    
    const initialDragState = {
      projectId,
      action,
      startX: e.clientX,
      lastMouseX: e.clientX,
      startY: e.clientY,
      originalStartDate: new Date(targetProject.startDate),
      originalEndDate: new Date(targetProject.endDate),
      lastDaysDelta: 0,
      pixelDeltaX: 0,
      lastSnappedDelta: 0
    };
    
    setIsDragging(true);
    setDragState(initialDragState);
    
  const handleMouseMove = (e: MouseEvent) => {
      try {
        // 🚫 PREVENT BROWSER DRAG BEHAVIOR: Stop any default drag actions
        e.preventDefault();

        // DEBUG: Confirm drag handler is being called
        if (Math.abs(e.clientX - initialDragState.lastMouseX) > 1) {
          console.log('🔥 DRAG HANDLER CALLED:', {
            clientX: e.clientX,
            lastMouseX: initialDragState.lastMouseX,
            delta: e.clientX - initialDragState.lastMouseX
          });
        }

        // Calculate incremental delta from last mouse position (prevents overshoot)
        const incrementalDeltaX = e.clientX - initialDragState.lastMouseX;
        const totalDeltaX = e.clientX - initialDragState.startX;
        const dayWidth = timelineMode === 'weeks' ? 11 : 40;

        // Always accumulate smooth movement for responsive pen/mouse following
        const currentPixelDeltaX = (initialDragState.pixelDeltaX || 0) + incrementalDeltaX;
        const smoothVisualDelta = currentPixelDeltaX / dayWidth;

        // For visual display: snap to day boundaries in days view, smooth in weeks view
        let visualDelta;
        if (timelineMode === 'weeks') {
          visualDelta = smoothVisualDelta;  // Smooth movement in weeks
        } else {
          // In days view: snap to nearest day boundary but prevent jumping
          const snappedDelta = Math.round(smoothVisualDelta);
          // Only update the snapped position if we've moved enough to cross a boundary
          const currentSnapped = initialDragState.lastSnappedDelta || 0;
          const minMovement = 0.3; // Require 30% of day width movement to snap
          if (Math.abs(snappedDelta - currentSnapped) >= 1 && Math.abs(smoothVisualDelta - currentSnapped) > minMovement) {
            visualDelta = snappedDelta;
            initialDragState.lastSnappedDelta = snappedDelta;
          } else {
            visualDelta = currentSnapped; // Stay at current snapped position until boundary crossed
          }
        }

        // Calculate rounded delta for database updates only
        const daysDelta = calculateDaysDelta(e.clientX, initialDragState.startX, dates, true, timelineMode);

        // DEBUG: Always log drag events to see if handler is being called
        console.log('🎯 DRAG MOVE EVENT:', {
          eventType: e.type,
          pointerType: (e as any).pointerType || 'mouse',
          clientX: e.clientX,
          clientY: e.clientY,
          incrementalDeltaX,
          currentPixelDeltaX,
          smoothVisualDelta,
          visualDelta,
          mode: timelineMode,
          dayWidth
        });

        // IMMEDIATE visual update for responsive UI (incremental movement)
        setDragState(prev => ({ 
          ...prev, 
          daysDelta: visualDelta,  // Use calculated visual delta
          pixelDeltaX: currentPixelDeltaX  // Accumulate smooth movement
        }));

        // Update last mouse position for next incremental calculation
        initialDragState.lastMouseX = e.clientX;        // Check for auto-scroll during drag
        checkAutoScroll(e.clientX);

        // BACKGROUND persistence (throttled database updates)
        if (daysDelta !== initialDragState.lastDaysDelta) {
          // Schedule database update with longer throttle for better performance
          const throttleMs = 0; // No throttling for immediate visual feedback like milestones

                  throttledDragUpdate(async () => {
                    if (action === 'resize-start-date') {
                      const newStartDate = new Date(initialDragState.originalStartDate);
                      newStartDate.setDate(newStartDate.getDate() + daysDelta);

                      const endDate = new Date(initialDragState.originalEndDate);
                      const oneDayBefore = new Date(endDate);
                      oneDayBefore.setDate(endDate.getDate() - 1);

                      // Simple validation - ensure start date is before end date
                      if (newStartDate <= oneDayBefore) {
                        updateProject(projectId, { startDate: newStartDate }, { silent: true });
                      }
                    } else if (action === 'resize-end-date') {
                      const newEndDate = new Date(initialDragState.originalEndDate);
                      newEndDate.setDate(newEndDate.getDate() + daysDelta);

                      const startDate = new Date(initialDragState.originalStartDate);
                      const oneDayAfter = new Date(startDate);
                      oneDayAfter.setDate(startDate.getDate() + 1);

                      // Simple validation - ensure end date is after start date
                      if (newEndDate >= oneDayAfter) {
                        updateProject(projectId, { endDate: newEndDate }, { silent: true });
                      }
                    } else if (action === 'move') {
                      const newStartDate = new Date(initialDragState.originalStartDate);
                      const newEndDate = new Date(initialDragState.originalEndDate);

                      newStartDate.setDate(newStartDate.getDate() + daysDelta);
                      newEndDate.setDate(newEndDate.getDate() + daysDelta);

                      // Update project and all milestones in parallel
                      const projectUpdate = updateProject(projectId, { 
                        startDate: newStartDate,
                        endDate: newEndDate 
                      }, { silent: true });

                      const projectMilestones = milestones.filter(m => m.projectId === projectId);
                      const milestoneUpdates = projectMilestones.map(milestone => {
                        const originalMilestoneDate = new Date(milestone.dueDate);
                        const newMilestoneDate = new Date(originalMilestoneDate);
                        newMilestoneDate.setDate(originalMilestoneDate.getDate() + daysDelta);

                        return updateMilestone(milestone.id, { 
                          dueDate: new Date(newMilestoneDate.toISOString().split('T')[0] + 'T00:00:00+00:00')
                        }, { silent: true });
                      });

                      Promise.all([projectUpdate, ...milestoneUpdates]);
                    }
                  }, throttleMs);

                  initialDragState.lastDaysDelta = daysDelta;
                }
              } catch (error) {
                console.error('🚨 PROJECT DRAG ERROR:', error);
              }
            };
    
    const handleMouseUp = () => {
      console.log('🛑 PROJECT DRAG END - All events cleaned up');
      setIsDragging(false);
      setDragState(null);
      stopAutoScroll(); // Fix infinite scrolling
      
      // Clear any pending drag updates for better performance
      clearDragQueue();
      
      // Show success toast when drag operation completes
      showProjectSuccessToast("Project updated successfully");
      
      // Remove ALL possible event listeners for robust pen/tablet support
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.removeEventListener('pointermove', handleMouseMove);
      document.removeEventListener('pointerup', handleMouseUp);
      document.removeEventListener('pointercancel', handleMouseUp);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleMouseUp);
      document.removeEventListener('touchcancel', handleMouseUp);
    };
    
    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length > 0) {
        const touch = e.touches[0];
        // Create a more complete mouse event for touch with both coordinates
        const mouseEvent = {
          clientX: touch.clientX,
          clientY: touch.clientY,
          preventDefault: () => e.preventDefault(),
          stopPropagation: () => e.stopPropagation()
        } as MouseEvent;
        handleMouseMove(mouseEvent);
      }
    };
    
    // Add comprehensive event listeners for all input types (mouse, pen, touch)
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('pointermove', handleMouseMove);
    document.addEventListener('pointerup', handleMouseUp);
    document.addEventListener('pointercancel', handleMouseUp); // Critical for pen input
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleMouseUp);
    document.addEventListener('touchcancel', handleMouseUp);
  }, [projects, dates, updateProject, checkAutoScroll, stopAutoScroll, timelineMode, milestones, updateMilestone, showProjectSuccessToast]);

  // COMPLETELY REWRITTEN HOLIDAY DRAG HANDLER - SIMPLE AND FAST
  const handleHolidayMouseDown = useCallback((e: React.MouseEvent, holidayId: string, action: string) => {
    e.preventDefault();
    e.stopPropagation();
    
    const targetHoliday = holidays.find(h => h.id === holidayId);
    if (!targetHoliday) return;
    
    console.log('🏖️ HOLIDAY DRAG START:', { action, holidayId });
    
    const startX = e.clientX;
    const dayWidth = timelineMode === 'weeks' ? 77 : 40;
    const originalStartDate = new Date(targetHoliday.startDate);
    const originalEndDate = new Date(targetHoliday.endDate);
    
    setIsDragging(true);
    
    const handleMouseMove = (e: MouseEvent) => {
      // 🚫 PREVENT BROWSER DRAG BEHAVIOR: Stop any default drag actions
      e.preventDefault();
      
      // Calculate exact visual delta (no rounding for smooth mouse following)
      const totalDeltaX = e.clientX - startX;
      
      // In weeks view: smooth movement, in days view: snap to day boundaries
      const exactVisualDelta = timelineMode === 'weeks' 
        ? totalDeltaX / dayWidth  // Smooth movement in weeks
        : Math.round(totalDeltaX / dayWidth);  // Snap to days in days view
      
      // Calculate rounded delta for database updates only
      const daysDelta = Math.round(exactVisualDelta);
      
      console.log(`🏖️ ${action.toUpperCase()}:`, { totalDeltaX, exactVisualDelta, daysDelta });
      
      try {
        if (action === 'resize-start-date') {
          const newStartDate = new Date(originalStartDate);
          newStartDate.setDate(originalStartDate.getDate() + daysDelta);
          
          // Allow start date to equal end date (single day holiday)
          if (newStartDate <= originalEndDate) {
            console.log('✅ START DATE UPDATE:', newStartDate.toDateString());
            updateHoliday(holidayId, { startDate: newStartDate });
          } else {
            console.log('❌ START DATE BLOCKED');
          }
          
        } else if (action === 'resize-end-date') {
          const newEndDate = new Date(originalEndDate);
          newEndDate.setDate(originalEndDate.getDate() + daysDelta);
          
          // Allow end date to equal start date (single day holiday)
          if (newEndDate >= originalStartDate) {
            console.log('✅ END DATE UPDATE:', newEndDate.toDateString());
            updateHoliday(holidayId, { endDate: newEndDate });
          } else {
            console.log('❌ END DATE BLOCKED');
          }
          
        } else if (action === 'move') {
          const newStartDate = new Date(originalStartDate);
          const newEndDate = new Date(originalEndDate);
          
          newStartDate.setDate(originalStartDate.getDate() + daysDelta);
          newEndDate.setDate(originalEndDate.getDate() + daysDelta);
          
          console.log('✅ MOVE UPDATE:', newStartDate.toDateString(), 'to', newEndDate.toDateString());
          updateHoliday(holidayId, { 
            startDate: newStartDate,
            endDate: newEndDate 
          });
        }
      } catch (error) {
        console.error('🚨 HOLIDAY UPDATE ERROR:', error);
      }
      
      checkAutoScroll(e.clientX);
    };
    
    const handleMouseUp = () => {
      console.log('🏖️ DRAG END');
      setIsDragging(false);
      setDragState(null);
      stopAutoScroll();
      
      // Remove ALL possible event listeners for robust pen/tablet support
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.removeEventListener('pointermove', handleMouseMove);
      document.removeEventListener('pointerup', handleMouseUp);
      document.removeEventListener('pointercancel', handleMouseUp);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleMouseUp);
      document.removeEventListener('touchcancel', handleMouseUp);
    };
    
    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length > 0) {
        const touch = e.touches[0];
        handleMouseMove({ clientX: touch.clientX } as MouseEvent);
      }
    };
    
    // Add comprehensive event listeners for all input types (mouse, pen, touch)
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('pointermove', handleMouseMove);
    document.addEventListener('pointerup', handleMouseUp);
    document.addEventListener('pointercancel', handleMouseUp); // Critical for pen input
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleMouseUp);
    document.addEventListener('touchcancel', handleMouseUp);
  }, [holidays, updateHoliday, checkAutoScroll, stopAutoScroll, timelineMode]);

  // Organize projects by groups for sidebar
  const groupsWithProjects = useMemo(() => {
    return groups.map(group => ({
      ...group,
      projects: projects.filter(project => project.groupId === group.id)
    }));
  }, [groups, projects]);

  // Handle creating projects from hover drag - opens modal for confirmation
  const handleCreateProject = useCallback((rowId: string, startDate: Date, endDate: Date) => {
  console.log('🎯 TimelineView.handleCreateProject called with rowId:', rowId, 'startDate:', startDate, 'endDate:', endDate);
  console.log('🎯 DETAILED: startDate ISO:', startDate.toISOString(), 'endDate ISO:', endDate.toISOString());
  console.log('🎯 Available rows:', rows.map(r => ({ id: r.id, groupId: r.groupId, name: r.name })));
    const row = rows.find(r => r.id === rowId);
    if (!row) {
      console.error('❌ Row not found for rowId:', rowId);
      console.error('❌ Available row IDs:', rows.map(r => r.id));
      return;
    }

  console.log('✅ Found row:', row, 'groupId:', row.groupId);
  console.log('✅ Row object keys:', Object.keys(row));
  console.log('✅ Row groupId type:', typeof row.groupId, 'value:', JSON.stringify(row.groupId));

    // REMOVED: Competing overlap check - SmartHoverAddProjectBar already validated this is safe
    // SmartHoverAddProjectBar prevents creation in occupied spaces, so we trust its validation

  console.log('🚀 Opening project creation modal with rowId:', rowId, 'groupId:', row.groupId, 'dates:', { startDate, endDate });
  console.log('🚀 DETAILED: About to call setCreatingNewProject with startDate ISO:', startDate.toISOString(), 'endDate ISO:', endDate.toISOString());
    // Open the project creation modal with the selected dates and row
    setCreatingNewProject(row.groupId, { startDate, endDate }, rowId);
  }, [rows, setCreatingNewProject, projects]);

  // Handle milestone drag updates
  const handleMilestoneDrag = useCallback((milestoneId: string, newDate: Date) => {
    updateMilestone(milestoneId, { dueDate: newDate }, { silent: true });
  }, [updateMilestone]);

  // Handle milestone drag end
  const handleMilestoneDragEnd = useCallback(() => {
    showMilestoneSuccessToast("Milestone updated successfully");
  }, [showMilestoneSuccessToast]);

  return (
    <DndProvider backend={HTML5Backend}>
      <TooltipProvider>
        <AppPageLayout>
          {/* Timeline Header */}
          <AppPageLayout.Header className="h-20 border-b border-[#e2e2e2] flex items-center justify-between px-8">
            <TimelineHeader 
              currentDate={currentDate}
              viewportStart={viewportStart}
              viewportEnd={viewportEnd}
              onNavigate={handleNavigate}
              onGoToToday={handleGoToToday}
            />
          </AppPageLayout.Header>
          
          {/* Timeline Mode Toggle and Navigation */}
          <AppPageLayout.SubHeader>
            <TimelineControls
              timelineMode={timelineMode}
              setTimelineMode={setTimelineMode}
              currentDate={currentDate}
              isDatePickerOpen={isDatePickerOpen}
              setIsDatePickerOpen={setIsDatePickerOpen}
              handleDateSelect={handleDateSelect}
              projectSearchQuery={projectSearchQuery}
              setProjectSearchQuery={setProjectSearchQuery}
              handleNavigate={handleNavigate}
              handleGoToToday={handleGoToToday}
              dateRangeText={dateRangeText}
            />
          </AppPageLayout.SubHeader>
          
          {/* Main Content Area with Card */}
          <AppPageLayout.Content>
            <div className="flex-1 flex flex-col min-h-0 pt-[0px] pr-[0px] pb-[21px] pl-[0px]">
              {/* Timeline Card */}
              <Card className="flex-1 flex flex-col overflow-hidden relative timeline-card-container">
                {/* Column Markers - covers timeline area only, doesn't scroll */}
                <div className="absolute pointer-events-none z-1" style={{
                  top: '48px', // Below date header
                  bottom: '52px', // Above holiday row
                  left: collapsed ? '48px' : '280px', // After sidebar
                  right: 0,
                  transition: 'left 300ms cubic-bezier(0.4, 0, 0.2, 1)',
                  willChange: 'left'
                }}>
                  <TimelineColumnMarkers dates={dates} mode={mode} />
                  {/* Full-column holiday overlays that span the full scroll window */}
                  <TimelineHolidayOverlay
                    holidays={holidays}
                    dates={dates}
                    mode={mode}
                  />

                </div>
                <div className="flex flex-col min-h-full bg-white">
                  {/* Fixed Headers Row */}
                  <div className="flex border-b border-gray-200 bg-white relative z-10">
                    {/* Sidebar Header */}
                    <div 
                      className="bg-white border-r border-gray-200 flex items-center py-2 relative"
                      style={{ 
                        width: collapsed ? '48px' : '280px',
                        minWidth: collapsed ? '48px' : '280px',
                        transition: 'width 300ms cubic-bezier(0.4, 0, 0.2, 1), min-width 300ms cubic-bezier(0.4, 0, 0.2, 1)',
                        willChange: 'width, min-width',
                        zIndex: 25
                      }}
                    >
                      <div className={`flex items-center w-full ${collapsed ? 'justify-center' : 'px-4 gap-3'}`}>
                        {collapsed ? (
                          <Folders className="w-4 h-4 text-gray-600" />
                        ) : (
                          <>
                            <Folders className="w-4 h-4 text-gray-600" />
                            <span>Projects</span>
                          </>
                        )}
                      </div>
                      
                      {/* Collapse Toggle Button */}
                      <button
                        onClick={handleToggleCollapse}
                        className="absolute top-3 -right-3 w-6 h-6 bg-white border border-border rounded-md flex items-center justify-center text-gray-500 hover:text-gray-600 hover:bg-gray-50 transition-colors duration-200 z-20"
                      >
                        <PanelLeft className="w-4 h-4" />
                      </button>
                    </div>
                    
                    {/* Date Headers */}
                    <div className="flex-1 bg-white" style={{ 
                      minWidth: `${dates.length * (mode === 'weeks' ? 77 : 40)}px`
                    }}>
                      <TimelineDateHeaders dates={dates} mode={mode} />
                    </div>
                  </div>
                  
                  {/* Scrollable Content Area */}
                  <TimelineProjectRenderer
                    groups={groups}
                    rows={rows}
                    projects={projects}
                    dates={dates}
                    viewportStart={viewportStart}
                    viewportEnd={viewportEnd}
                    collapsed={collapsed}
                    collapsedGroups={collapsedGroups}
                    isDragging={isDragging}
                    dragState={dragState}
                    mode={mode}
                    handleMouseDown={handleMouseDown}
                    handleCreateProject={handleCreateProject}
                    handleMilestoneDrag={handleMilestoneDrag}
                    handleMilestoneDragEnd={handleMilestoneDragEnd}
                  />
                  
                  {/* Fixed Add Holiday Row at bottom */}
                  <div className="border-t border-gray-200 bg-yellow-200">
                    <AddHolidayRow 
                      dates={dates} 
                      collapsed={collapsed} 
                      isDragging={isDragging}
                      dragState={dragState}
                      handleHolidayMouseDown={handleHolidayMouseDown}
                      mode={timelineMode}
                    />
                  </div>
                </div>
                
                {/* Hoverable Timeline Scrollbar - positioned above holiday row */}
                <HoverableTimelineScrollbar
                  viewportStart={viewportStart}
                  setViewportStart={setViewportStart}
                  setCurrentDate={setCurrentDate}
                  VIEWPORT_DAYS={VIEWPORT_DAYS}
                  isAnimating={isAnimating}
                  setIsAnimating={setIsAnimating}
                  sidebarWidth={collapsed ? 48 : 280}
                  bottomOffset={54}
                  isDragging={isDragging}
                  stopAutoScroll={stopAutoScroll}
                />
              </Card>
              
              {/* Availability Display Mode Toggle */}
              <div className="mt-4 mb-4 flex justify-start">
                <ToggleGroup
                  type="single"
                  value={availabilityDisplayMode}
                  onValueChange={(value) => {
                    if (value) {
                      setAvailabilityDisplayMode(value as 'circles' | 'numbers');
                    }
                  }}
                  variant="outline"
                  className="border border-gray-200 rounded-lg h-9 p-1"
                >
                  <ToggleGroupItem value="circles" aria-label="Circles mode" className="px-2 py-1 h-7">
                    <Circle className="w-4 h-4" />
                  </ToggleGroupItem>
                  <ToggleGroupItem value="numbers" aria-label="Numbers mode" className="px-2 py-1 h-7">
                    <Hash className="w-4 h-4" />
                  </ToggleGroupItem>
                </ToggleGroup>
              </div>
              
              {/* Availability Timeline Card */}
              <TimelineAvailabilityContent
                dates={dates}
                projects={projects}
                settings={settings}
                mode={mode}
                availabilityDisplayMode={availabilityDisplayMode}
                viewportStart={viewportStart}
                setViewportStart={setViewportStart}
                setCurrentDate={setCurrentDate}
                VIEWPORT_DAYS={VIEWPORT_DAYS}
                isAnimating={isAnimating}
                setIsAnimating={setIsAnimating}
                collapsed={collapsed}
                isDragging={isDragging}
                stopAutoScroll={stopAutoScroll}
                holidays={holidays}
              />
              
              {/* Timeline Scrollbar - Outside the cards, at bottom of viewport */}
              <div className="mt-4">
                <PerformanceStatus className="mt-2" />
              </div>
            </div>
          </AppPageLayout.Content>
        </AppPageLayout>
      </TooltipProvider>
    </DndProvider>
  );
}