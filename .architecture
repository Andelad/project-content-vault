# üèóÔ∏è Architecture Guide

> **Purpose:** Understand the codebase structure, where to find things, and why we organized it this way.
> 
> **For quick AI instructions:** See `.cursorrules`
> 
> **For business rules:** See `/src/domain/` documentation
> 
> **For testing:** See `/docs/operations/TESTING_GUIDE.md`

**Last Updated:** January 8, 2026  
**Architecture:** Hybrid DDD (pragmatic domain-driven design)  
**Tests:** 547 tests via Vitest (co-located in `__tests__/` directories)

---

## üìö Documentation Map

All documentation lives near the code it describes:

| Document | Location | Purpose |
|----------|----------|---------|
| **`.cursorrules`** | Project root | AI quick reference - what to do/not do |
| **`.architecture`** | Project root | This file - codebase map and structure |
| **`.ddd`** | Project root | Hybrid DDD philosophy & architecture evolution |
| **`App Logic.md`** | `/src/domain/` | What entities are, domain concepts |
| **`Business Rules.md`** | `/src/domain/` | How rules work, calculations, formulas |
| **`Display Logic.md`** | `/src/services/ui/` | View-specific display constraints |
| **`README.md`** | `/src/components/` | Component file organization |
| **`TESTING_GUIDE.md`** | `/docs/operations/` | Testing patterns, coverage, examples |

---

## üèõÔ∏è Architecture Philosophy: Hybrid DDD

### What is Hybrid DDD?

This codebase uses **Hybrid Domain-Driven Design** - a pragmatic middle ground:

**Pure in Documentation:**
- Domain concepts fully separated in docs (`Domain Logic.md`, `Rules Logic.md`)
- Clear boundaries between domain rules and UI concerns
- Business logic documented independent of implementation

**Pragmatic in Code:**
- Orchestrators intentionally mix application logic + DB access + UI prep
- No repository layer (direct Supabase calls)
- Domain entities gradually adopted (not enforced everywhere)

### Why Hybrid Instead of Strict DDD?

| Approach | Separation | Repository Layer | Development Speed | Best For |
|----------|------------|------------------|-------------------|----------|
| **Strict DDD** | 100% code separation | Required | Slower | Large teams, multiple clients |
| **Hybrid DDD** (ours) | Doc separation, code pragmatic | None (direct Supabase) | Faster | Small teams, single product |
| **No DDD** | Mixed everywhere | None | Fastest short-term | Prototypes only |

**Trade-off:** We sacrifice some architectural purity for development velocity, but maintain clarity through documentation.

---

## üó∫Ô∏è Codebase Map

### Where to Find Things

```
src/
‚îú‚îÄ‚îÄ domain/                          # üìñ Layer 1: Pure business logic
‚îÇ   ‚îú‚îÄ‚îÄ App Logic.md                # What entities ARE
‚îÇ   ‚îú‚îÄ‚îÄ Business Rules.md           # How rules WORK
‚îÇ   ‚îú‚îÄ‚îÄ rules/                      # ‚úÖ ALL business logic (validation + calculations)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __tests__/              # üß™ Domain rule tests (165 tests)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phases/                 # Phase-specific rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ projects/               # Project-specific rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sync/                   # Cross-cutting sync logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events/                 # Event rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ availability/           # Capacity & work hours
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clients/                # Client validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ holidays/               # Holiday calculations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ work-slots/             # Work slot rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ time-tracking/          # Time tracker logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ timeline/               # Timeline display rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ integrity/              # Cross-entity validation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cascade/                # Deletion impact
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ... (18 subdirectories total)
‚îÇ   ‚îú‚îÄ‚îÄ entities/                   # Rich domain models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __tests__/              # üß™ Entity tests (69 tests)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Project.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Phase.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Client.ts
‚îÇ   ‚îî‚îÄ‚îÄ value-objects/              # Immutable value types
‚îÇ       ‚îú‚îÄ‚îÄ DateRange.ts
‚îÇ       ‚îî‚îÄ‚îÄ EmailAddress.ts
‚îÇ
‚îú‚îÄ‚îÄ services/                        # üîß Layer 2: Application & infrastructure services
‚îÇ   ‚îú‚îÄ‚îÄ orchestrators/              # Workflows (coordination ONLY)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __tests__/              # üß™ Orchestrator tests (82 tests)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProjectOrchestrator.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PhaseOrchestrator.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CalendarEventOrchestrator.ts
‚îÇ   ‚îú‚îÄ‚îÄ data/                       # Data transformation & aggregation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mappers/                # DB‚ÜîDomain translation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProjectMapper.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PhaseMapper.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ aggregators/            # Multi-table queries
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ProjectAggregate.ts
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/             # Cross-cutting technical concerns
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorHandlingService.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TimeTrackerStorage.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ caching/
‚îÇ   ‚îî‚îÄ‚îÄ ui/                         # View positioning & layout
‚îÇ       ‚îú‚îÄ‚îÄ Display Logic.md        # View-specific display constraints
‚îÇ       ‚îú‚îÄ‚îÄ ProjectBarPositioning.ts
‚îÇ       ‚îú‚îÄ‚îÄ TimelineViewportService.ts
‚îÇ       ‚îî‚îÄ‚îÄ DragCoordinator.ts
‚îÇ
‚îú‚îÄ‚îÄ components/                      # üé® Layer 3: React UI
‚îÇ   ‚îú‚îÄ‚îÄ README.md                   # Component organization guide
‚îÇ   ‚îú‚îÄ‚îÄ shadcn/                     # Design system components (shadcn/ui)
‚îÇ   ‚îú‚îÄ‚îÄ views/                      # Page-level components
‚îÇ   ‚îú‚îÄ‚îÄ features/                   # Feature-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ timeline/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ planner/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ projects/
‚îÇ   ‚îú‚îÄ‚îÄ shared/                     # Reusable components
‚îÇ   ‚îú‚îÄ‚îÄ modals/                     # Modal dialogs
‚îÇ   ‚îî‚îÄ‚îÄ layout/                     # Layout components
‚îÇ
‚îú‚îÄ‚îÄ hooks/                           # ‚öõÔ∏è React hooks (organized by concern)
‚îÇ   ‚îú‚îÄ‚îÄ data/                       # Data fetching hooks
‚îÇ   ‚îú‚îÄ‚îÄ ui/                         # UI interaction hooks
‚îÇ   ‚îú‚îÄ‚îÄ phase/                      # Phase-specific hooks
‚îÇ   ‚îú‚îÄ‚îÄ calendar/                   # Calendar hooks
‚îÇ   ‚îú‚îÄ‚îÄ timeline/                   # Timeline hooks
‚îÇ   ‚îú‚îÄ‚îÄ insights/                   # Insights calculations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useDebouncedCalculation.ts  # Performance optimization hook
‚îÇ   ‚îî‚îÄ‚îÄ settings/                   # Settings hooks
‚îÇ
‚îú‚îÄ‚îÄ types/                           # üìù Type definitions
‚îÇ   ‚îî‚îÄ‚îÄ core.ts                     # Central type definitions
‚îÇ
‚îî‚îÄ‚îÄ utils/                           # üõ†Ô∏è Generic utilities
    ‚îú‚îÄ‚îÄ __tests__/                  # üß™ Utility tests (186 tests)
    ‚îú‚îÄ‚îÄ dateCalculations.ts         # Pure date math
    ‚îú‚îÄ‚îÄ dateFormatUtils.ts          # Display formatting
    ‚îî‚îÄ‚îÄ timeCalculations.ts         # Time utilities
```

### Layer Responsibilities

| Layer | What It Does | What It Doesn't Do | Tests |
|-------|--------------|-------------------|-------|
| **Domain Rules** | ALL business logic (validation + calculations inline) | No UI, no DB, no presentation | ‚úÖ 165 tests |
| **Domain Entities** | Rich objects with behavior | No UI concerns, no DB calls | ‚úÖ 69 tests |
| **Value Objects** | Immutable primitives with validation | No side effects, no mutations | ‚è∏Ô∏è Deferred |
| **Orchestrators** | Workflows, coordination, DB access, UI prep | No business logic (use domain/rules) | ‚úÖ 82 tests |
| **Data Services** | DB‚ÜîDomain transformation, multi-table aggregation | No business logic, no UI | ‚è∏Ô∏è Deferred |
| **Infrastructure** | Error handling, storage, caching | No business logic, no UI | ‚è∏Ô∏è Deferred |
| **UI Services** | View positioning, layout calculations | No business logic | ‚è∏Ô∏è Deferred |
| **Hooks** | React state + service coordination | No business logic | ‚ùå Not tested |
| **Components** | Display only | No logic, no calculations | ‚ùå Not tested |
| **Utilities** | Generic helpers (dates, formatting, time) | No business logic | ‚úÖ 186 tests |

**Test Total:** 547 tests passing ‚úÖ

---

## üéØ Three-Layer Documentation Model

Our documentation intentionally separates three concerns that code often mixes:

### 1. App Logic - WHAT (Concepts)
**File:** `/src/domain/App Logic.md`

**Contains:**
- Entity definitions (Project, Client, Phase, etc.)
- Time concepts (capacity, estimated, planned, completed)
- Workflows (how users interact with the system)
- Relationships between entities
- Plain English descriptions

**Example:**
> "Projects have three time types: auto-estimated, planned, and completed. All three coexist simultaneously in the domain."

### 2. Business Rules - HOW (Calculations)
**File:** `/src/domain/Business Rules.md`

**Contains:**
- Calculation formulas
- Validation rules
- Edge cases and constraints
- State transitions
- Detailed specifications

**Example:**
> "Auto-estimate = (Remaining Hours) √∑ (Days without events)"

### 3. Display Logic - WHERE (UI Constraints)
**File:** `/src/services/ui/Display Logic.md`

**Contains:**
- View-specific display rules
- Visual constraints (e.g., mutual exclusivity in Timeline)
- Presentation priorities
- How different views show the same data differently

**Example:**
> "Timeline View displays only ONE time type per day (mutual exclusivity constraint). Calendar View can show multiple."

### Why Separate These?

**Without separation:**
- Business rules get tangled with UI concerns
- Changes to one view affect understanding of domain
- Hard to know if a rule is universal or view-specific

**With separation:**
- Domain truth clear and view-independent
- UI constraints documented separately
- Easy to add new views without changing domain understanding

---

## üîß Services Architecture

### Domain Rules (ALL Business Logic) ‚úÖ

**Purpose:** ALL business logic - validation + calculations + algorithms

**Location:** `/src/domain/rules/`

**Characteristics:**
- 100% pure (no UI, no DB, no side effects)
- Fully testable without mocks
- Stateless static methods or pure functions
- Calculations inline (co-located with business logic)

**Organization:** 18 subdirectories by domain concern
```
domain/rules/
‚îú‚îÄ‚îÄ phases/          # Phase-specific rules (validation, recurrence, distribution, budget)
‚îú‚îÄ‚îÄ projects/        # Project-specific rules (validation, budget, metrics)
‚îú‚îÄ‚îÄ sync/            # Cross-cutting synchronization (date sync, budget sync)
‚îú‚îÄ‚îÄ events/          # Calendar event rules
‚îú‚îÄ‚îÄ availability/    # Capacity calculations & work hours
‚îú‚îÄ‚îÄ clients/         # Client validation
‚îú‚îÄ‚îÄ holidays/        # Holiday calculations
‚îú‚îÄ‚îÄ work-slots/      # Work slot rules
‚îú‚îÄ‚îÄ time-tracking/   # Time tracking logic
‚îú‚îÄ‚îÄ timeline/        # Timeline display rules
‚îú‚îÄ‚îÄ integrity/       # Cross-entity validation
‚îú‚îÄ‚îÄ cascade/         # Deletion impact analysis
‚îî‚îÄ‚îÄ ... (18 total)
```

**Example:**
```typescript
// ‚úÖ Domain rule (pure logic, calculations inline)
export class PhaseRecurrence {
  static generateOccurrences(
    config: RecurringConfig, 
    range: DateRange
  ): Date[] {
    // RRule logic + calculations inline
    // No separate MathUtils needed
    return rrule.all();
  }
  
  static validateRecurringConfig(
    config: RecurringConfig
  ): ValidationResult {
    // Validation logic
    if (config.frequency === 'WEEKLY' && !config.byweekday) {
      return { isValid: false, errors: ['Weekly requires days'] };
    }
    return { isValid: true };
  }
}
```

### Orchestrators (Workflows ONLY)

**Purpose:** Coordinate complex workflows involving validation + DB + side effects + UI prep

**Location:** `/src/services/orchestrators/`

**Characteristics:**
- Intentionally mixed concerns (by design in Hybrid DDD)
- Handle CREATE/UPDATE/DELETE operations
- Call domain rules for validation
- Call Supabase directly (no repository layer)
- Transform data for database
- Enrich data for UI display
- Trigger side effects

**Example Pattern:**
```typescript
class ProjectOrchestrator {
  static async createProject(input: ProjectInput) {
    // 1. Validate using domain rules
    const validation = ProjectRules.validate(input);
    if (!validation.isValid) return validation;
    
    // 2. Transform for database
    const dbData = this.transformForDB(input);
    
    // 3. Direct Supabase call
    const { data } = await supabase.from('projects').insert(dbData);
    
    // 4. Enrich for UI
    return this.enrichForDisplay(data);
  }
}
```

**Why no repository layer?**
- Supabase already provides type-safe queries
- Repository would just delegate with no added value
- Reduces boilerplate and development time

### Unified Services (Legacy - Delegates to Domain)

**Purpose:** Business-aware calculations that delegate to domain services (LEGACY - prefer domain-services for new code)

**Location:** `/services/unified/`

**Characteristics:**
- READ-only operations
- No side effects
- No database access
- **Should delegate to `domain/domain-services/`** (not implement logic directly)

**Current state:**
- ‚ö†Ô∏è Mix of pure domain logic and UI coordination
- ‚ö†Ô∏è Some overlap with domain-services
- ‚úÖ Gradually migrating pure logic to domain-services

**Example Pattern:**
```typescript
// ‚úÖ GOOD: Delegates to domain service
class UnifiedProjectService {
  static calculateBudget(project: Project, phases: Phase[]) {
    return ProjectBudgetService.analyzeBudget(project, phases);
  }
}

// ‚ö†Ô∏è ACCEPTABLE: UI coordination (keep here)
class UnifiedCalendarService {
  static transformForFullCalendar(events: CalendarEvent[]) {
    // FullCalendar-specific transformation (UI concern)
    return events.map(e => ({ title: e.name, ... }));
  }
}

// ‚ùå BAD: Pure domain logic (move to domain-services)
class UnifiedWorkHoursService {
  static calculateWeeklyHours(workDays: number[]) {
    // This should be in domain-services, not here
  }
}
```

**What to keep vs migrate:**
- **Keep:** UI coordination, FullCalendar integration, presentation logic
- **Migrate:** Pure calculations, RRule logic, business algorithms
- **See:** `docs/sessions/services-architecture-analysis.md` for detailed guidance

### Calculations (Pure Math)

**Purpose:** Pure mathematical functions with no business context

**Location:** `/src/services/calculations/general/`

**Characteristics:**
- No business logic
- No database access
- No side effects
- Reusable across any context

**Example:**
```typescript
// ‚úÖ Pure math
export function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

// ‚ùå Not pure (has business context)
export function calculateProjectEndDate(project: Project): Date {
  // This belongs in UnifiedProjectService or ProjectRules
}
```

---

## üèóÔ∏è Domain Layer (Entities & Rules)

### Domain Entities

**Purpose:** Rich objects that encapsulate business logic and prevent invalid states

**Location:** `/src/domain/entities/`

**When to use:**
- Need to enforce invariants at construction
- Business behavior naturally belongs to one entity
- Want discoverable API for operations
- Prevent invalid states

**Example:**
```typescript
// Factory method enforces validation
const result = Project.create({
  name: "Website",
  clientId: "123",
  startDate: new Date(),
  endDate: new Date(),
  estimatedHours: 120
});

if (result.success) {
  const project = result.data;
  
  // Methods encapsulate business logic
  project.updateDates(newStart, newEnd);
  project.convertToContinuous();
  
  // Query methods
  const isActive = project.isActiveOnDate(today);
  const duration = project.getDurationDays();
}
```

**Current Status:**
- ‚úÖ Project entity (complete)
- üöß Client, Phase, Group, Label (planned)

### Domain Rules

**Purpose:** Shared business rules used across multiple entities

**Location:** `/src/domain/rules/`

**When to use:**
- Validation spans multiple entities
- Shared business constraints
- Complex cross-entity rules

**Example:**
```typescript
// Used by orchestrators
const validation = RelationshipRules.validateProjectPhases(
  project, 
  phases
);

// Used internally by entities
class Project {
  getBudgetAnalysis() {
    return ProjectRules.analyzeBudget(this.toData(), this.phases);
  }
}
```

---

## üìñ When to Update Documentation

### Update Domain Docs When:
- ‚úÖ Entity definitions change (App Logic.md)
- ‚úÖ Business rules change (Business Rules.md)
- ‚úÖ Calculations/formulas change (Business Rules.md)
- ‚úÖ View display constraints change (services/ui/Display Logic.md)
- ‚úÖ Relationships between entities change (App Logic.md)

### Don't Update Domain Docs For:
- ‚ùå Bug fixes
- ‚ùå Performance optimizations
- ‚ùå Refactoring (same behavior)
- ‚ùå Test additions
- ‚ùå UI styling changes

### Update This File (.architecture) When:
- Adding new layers or directories
- Changing architectural patterns
- Adding new service types
- Significant restructuring

---

## üîÑ Migration Notes

### From Milestone to Phase (December 2025)

**Status:** In progress

**Changes:**
- Renamed `MilestoneRules` ‚Üí `PhaseRules`
- Renamed `UnifiedMilestoneService` ‚Üí `UnifiedPhaseService`
- Updated all orchestrators to use new terminology

**Why:** "Milestone" was confusing - implied completion markers rather than time budgeting periods

### Future: Strict DDD (If Needed)

**When to consider:**
- Team grows beyond 7 developers
- Need to build separate API or mobile client
- Domain logic leaking into orchestrators becomes painful

**Effort:** 8-12 weeks to add repository layer + extract presentation logic

**Current decision:** Stay Hybrid until pain points emerge

---

## üé® Component Organization

See `/src/components/README.md` for detailed component organization guide.

**Quick reference:**
- `/views/` - Page-level components (route containers)
- `/features/` - Feature-specific components
- `/shared/` - Reusable generic components
- `/ui/` - Design system primitives (shadcn)
- `/modals/` - Full modal dialogs

---

## üìã Common Patterns

### Adding a New Feature

1. **Check domain docs** - Does the entity/rule exist?
2. **Add domain logic** if needed (domain rules, entities)
3. **Create orchestrator** for workflows
4. **Add unified service** for calculations
5. **Build UI components** using services
6. **Update documentation** if domain changed

### Adding Business Logic

**For complex domain logic (calculations, algorithms):**
1. **Create in `/src/domain/domain-services/`** (pure, stateless)
2. **Update `/src/domain/Rules Logic.md`** with formulas
3. **Use from orchestrators** (call the service directly)
4. **Never implement in orchestrators, unified services, or components**

**For simple validation:**
1. **Update `/src/domain/Rules Logic.md`** first
2. **Implement in `/src/domain/rules/`**
3. **Use from orchestrators/domain-services**

### Adding a Calculation

1. Is it pure math? ‚Üí `/services/calculations/`
2. Has business context? ‚Üí `/services/unified/` (delegate to calculations)
3. Entity-specific? ‚Üí Domain entity method

---

## üöÄ Development Workflow

### For Database Changes
1. Create `INSTRUCTIONS_FOR_LOVABLE_[FEATURE].md`
2. Include SQL and verification steps
3. Push to GitHub for Lovable to execute
4. Never run SQL migrations directly in VS Code

### For Code Changes
1. Check existing code first (`grep -r "functionName"`)
2. Import from `@/services` (barrel exports)
3. Use types from `/types/core.ts`
4. Use `dateCalculations` for dates
5. Use `ErrorHandlingService` for errors

---

## üìä Type System

### Single Source of Truth
**All core types in:** `/types/core.ts`

**Never:**
- ‚ùå Redefine core types in components
- ‚ùå Create duplicate interfaces

**OK to:**
- ‚úÖ Extend core types for component props
- ‚úÖ Add temporary UI-specific fields

```typescript
// ‚úÖ Extend for component use
interface LocalProject extends Project {
  isSelected?: boolean;
  isEditing?: boolean;
}

// ‚ùå Redefine
interface Project { id: string; name: string; } // NO!
```

---

## üéØ Quick Decision Matrix

| I need to... | Location | Reason |
|--------------|----------|--------|
| **Pure domain logic** | `domain/domain-services/` | **üÜï NEW CODE GOES HERE** |
| Validate a project | `domain/rules/ProjectRules.ts` | Business rule |
| Create a project | `orchestrators/ProjectOrchestrator.ts` | Workflow |
| Calculate budget/recurrence | `domain/domain-services/` | Pure domain logic |
| Legacy calculation | `unified/UnifiedProjectService.ts` | ‚ö†Ô∏è Delegates to domain-services |
| Add days to a date | `calculations/general/dateCalculations.ts` | Pure math |
| Fetch projects | `hooks/useProjects.ts` | Data fetching |
| Display a project | `components/features/projects/` | UI |
| Define Project type | `types/core.ts` | Type definition |

---

## üìö Further Reading

- **Hybrid DDD philosophy:** `.ddd` (root)
- **Domain concepts & entities:** `/src/domain/App Logic.md`
- **Business rules & formulas:** `/src/domain/Business Rules.md`
- **Display constraints:** `/src/services/ui/Display Logic.md`
- **Component organization:** `/src/components/README.md`
- **AI quick reference:** `.cursorrules`
