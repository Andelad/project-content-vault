# Architecture Philosophy: Hybrid DDD

**Last Updated:** January 7, 2026  
**Current Approach:** Hybrid Domain-Driven Design (DDD) - Three-Layer Architecture  
**Migration Status:** âœ… SUBSTANTIALLY COMPLETE - See `/docs/operations/ARCHITECTURE_REBUILD_PLAN.md`

---

## âœ… ARCHITECTURE SIMPLIFICATION COMPLETE (January 2026)

### The Problem We Solved

Business logic was scattered across 5+ layers:
- `domain/rules/` (validation)
- `domain/domain-services/` (pure algorithms) â† **DELETED**
- `services/unified/` (mixed logic + data) â† **DELETED**
- `services/calculations/` (pure math) â† **DELETED**
- `services/orchestrators/` (coordination + logic leakage)

**Result:** "Where does this go?" had multiple correct answers.

### The Solution: Three Clear Layers (IMPLEMENTED)

```
ğŸ“ Current Architecture (THREE LAYERS):

Layer 1: domain/                    â† Pure business logic (NO UI, NO DB)
â”œâ”€â”€ rules/                          â† ALL business logic (validation + calculations)
â”‚   â”œâ”€â”€ phases/                     â† Phase rules organized by concern
â”‚   â”œâ”€â”€ projects/                   â† Project rules
â”‚   â”œâ”€â”€ sync/                       â† Cross-cutting (date/budget sync)
â”‚   â”œâ”€â”€ events/                     â† Calendar event rules
â”‚   â”œâ”€â”€ availability/               â† Capacity & work hours
â”‚   â”œâ”€â”€ clients/                    â† Client validation
â”‚   â”œâ”€â”€ holidays/                   â† Holiday calculations
â”‚   â”œâ”€â”€ work-slots/                 â† Work slot rules
â”‚   â”œâ”€â”€ time-tracking/              â† Time tracker logic
â”‚   â”œâ”€â”€ timeline/                   â† Timeline display rules
â”‚   â”œâ”€â”€ integrity/                  â† Cross-entity validation
â”‚   â””â”€â”€ cascade/                    â† Deletion impact rules
â”œâ”€â”€ entities/                       â† Rich domain models
â””â”€â”€ value-objects/                  â† Immutable primitives (DateRange, etc.)

Layer 2: services/                  â† Application & infrastructure services
â”œâ”€â”€ orchestrators/                  â† Workflows (coordination ONLY)
â”œâ”€â”€ data/                           â† Data transformation & aggregation
â”‚   â”œâ”€â”€ mappers/                    â† DBâ†”Domain translation
â”‚   â””â”€â”€ aggregators/                â† Multi-table queries
â”œâ”€â”€ infrastructure/                 â† Cross-cutting technical concerns
â”‚   â”œâ”€â”€ ErrorHandlingService.ts
â”‚   â”œâ”€â”€ TimeTrackerStorage.ts
â”‚   â””â”€â”€ caching/                    â† Performance optimization
â””â”€â”€ ui/                             â† View-specific positioning & layout
    â”œâ”€â”€ ProjectBarPositioning.ts
    â”œâ”€â”€ TimelineViewportService.ts
    â”œâ”€â”€ DragCoordinator.ts
    â””â”€â”€ CalendarLayout.ts

Layer 3: components/                â† React UI (depends on services)
â”œâ”€â”€ shadcn/                         â† Design system components (shadcn/ui)
â”œâ”€â”€ features/                       â† Feature-specific components
â”œâ”€â”€ views/                          â† Page-level components
â”œâ”€â”€ shared/                         â† Reusable components
â”œâ”€â”€ modals/                         â† Modal dialogs
â””â”€â”€ layout/                         â† Layout components
```

### Key Decisions (January 7, 2026)

| Decision | Status | Rationale |
|----------|--------|-----------|
| **Merge domain-services â†’ rules** | âœ… DONE | Same purity, fewer folders to navigate |
| **NO MathUtils** | âœ… DONE | Keep calculations inline with business logic |
| **NO separate calculations layer** | âœ… DONE | Math belongs with the rules that use it |
| **Split unified services** | âœ… DONE | Logic â†’ rules, data â†’ services/data |
| **Cross-cutting in sync/** | âœ… DONE | Explicit home for phaseâ†”project interactions |
| **Infrastructure in services/** | âœ… DONE | Error handling, storage, caching consolidated |
| **UI services in services/ui/** | âœ… DONE | View positioning separate from components |
| **Rename components/ui â†’ shadcn** | âœ… DONE | Clear distinction from services/ui |

### What Got Deleted/Moved

```
âœ… domain/domain-services/          â†’ MERGED into domain/rules/
âœ… services/calculations/           â†’ MERGED into domain/rules/
âœ… services/unified/                â†’ SPLIT: logicâ†’rules, dataâ†’services/data/
âœ… infrastructure/                  â†’ MOVED to services/infrastructure/
âœ… ui/                              â†’ MOVED to services/ui/
âœ… components/ui/                   â†’ RENAMED to components/shadcn/
```

### Current Status

âœ… **Architecture rebuild SUBSTANTIALLY COMPLETE**
- Three-layer structure enforced
- Zero naming ambiguity
- All business logic in domain/rules/
- Clear separation of concerns

---

## Our Current Philosophy: Hybrid DDD

### What We Do

**Pure Documentation, Pragmatic Code**

We maintain **strict separation in documentation** while allowing **pragmatic mixing in code**:

```
ğŸ“š Documentation (Co-located with Code):
â”œâ”€â”€ /.architecture              â†’ Overall architecture philosophy
â”œâ”€â”€ /.ddd                       â†’ This file - Hybrid DDD evolution
â”œâ”€â”€ /src/domain/
â”‚   â”œâ”€â”€ App Logic.md            â†’ Domain concepts (100% UI-agnostic)
â”‚   â”œâ”€â”€ Business Rules.md       â†’ Domain rules & calculations (UI-agnostic)
â”‚   â””â”€â”€ Display Logic.md        â†’ Display-specific business rules
â””â”€â”€ /src/components/
    â””â”€â”€ README.md               â†’ Component organization

ğŸ’» Code (Three Layers - CURRENT STATE):
â”œâ”€â”€ domain/                     â†’ Layer 1: Pure business logic
â”‚   â”œâ”€â”€ entities/               â†’ Rich domain models âœ…
â”‚   â”œâ”€â”€ rules/                  â†’ ALL business logic (validation + calculations) âœ…
â”‚   â””â”€â”€ value-objects/          â†’ Immutable domain primitives âœ…
â”œâ”€â”€ services/                   â†’ Layer 2: Application & infrastructure services
â”‚   â”œâ”€â”€ orchestrators/          â†’ Workflows only (NO logic) âœ…
â”‚   â”œâ”€â”€ data/                   â†’ Transformation + aggregation âœ…
â”‚   â”œâ”€â”€ infrastructure/         â†’ Error handling, storage, caching âœ…
â”‚   â””â”€â”€ ui/                     â†’ View positioning & layout âœ…
â””â”€â”€ components/                 â†’ Layer 3: React UI
    â”œâ”€â”€ shadcn/                 â†’ Design system components (shadcn/ui) âœ…
    â”œâ”€â”€ features/               â†’ Feature components âœ…
    â”œâ”€â”€ views/                  â†’ Page components âœ…
    â””â”€â”€ shared/                 â†’ Reusable components âœ…
```

**Key Principle:** Documentation lives near the code it describes.
- All domain documentation together in `/src/domain/`
- Component organization in `/src/components/`
- Architecture at project root (alongside `.cursorrules`)

### Where We Stay Pure

**Domain Layer** (`domain/`) - Never compromise:

1. **Entities** (`domain/entities/`) - Things with identity:
   - âœ… Encapsulate state + behavior
   - âœ… Validate on construction
   - âœ… Self-contained business logic
   - âŒ NO UI concerns

2. **Value Objects** (`domain/value-objects/`) - Primitive concepts:
   - âœ… Immutable by design
   - âœ… Self-validating
   - âœ… Defined by value, not identity
   - âœ… Examples: DateRange, EmailAddress, PhoneNumber, Color
   - âŒ NO side effects

3. **Rules** (`domain/rules/`) - ALL business logic (validation + calculations):
   - âœ… Pure business rules
   - âœ… Calculations inline (no separate math utilities)
   - âœ… Organized by concern (phases/, projects/, sync/)
   - âŒ NO UI references ("timeline", "calendar", "view")
   - âŒ NO persistence logic
   - âŒ NO presentation logic

### Where We Mix (Intentionally)

**Orchestrators** (`services/orchestrators/`) - Pragmatic glue layer:
- âœ… Application workflows (CREATE/UPDATE/DELETE)
- âœ… Call domain rules (PhaseValidation.validate(), DateSync.synchronize())
- âœ… Direct database access (supabase.from()... - NO repository layer)
- âœ… Use data mappers for transformation
- âœ… Enrich for UI display (presentation prep)
- âœ… Coordinate side effects (notifications, updates)
- âŒ NO business logic (goes in domain/rules/)
- âŒ NO calculations (goes in domain/rules/ inline)

**Example:**
```typescript
async createProject(data: CreateProjectInput) {
  // âœ… Call domain rules (validation + calculations)
  const validation = ProjectValidation.validateCreate(data);
  if (!validation.isValid) return validation;
  
  // âœ… Use data mapper for DB transformation
  const dbData = ProjectMapper.toDatabase(data);
  
  // âœ… Direct DB access (no repository layer)
  const { data: project } = await supabase.from('projects').insert(dbData).select().single();
  
  // âœ… Use data mapper for UI transformation
  return ProjectMapper.fromDatabase(project);
}
```

### Why Hybrid?

**Velocity vs Purity Trade-off:**

| Aspect | Strict DDD | Hybrid DDD (Our Choice) |
|--------|-----------|-------------------------|
| **Layer Separation** | 100% code separation | Pure domain, mixed orchestrators |
| **Repository Layer** | Required abstraction | Direct Supabase calls |
| **Entity Usage** | Everywhere | Domain layer only |
| **Development Speed** | Slower (more abstraction) | Faster (pragmatic) |
| **Maintenance Clarity** | Code self-documents | Documentation self-documents |

**Our Bet:** Clear documentation + simple three-layer structure provides architectural clarity faster than full code separation.

---

## Value Objects (Added December 2025)

### What Are Value Objects?

**Value Objects** represent primitive domain concepts that:
- Are **immutable** (cannot change after creation)
- Are defined by their **value**, not identity (two DateRanges with same dates are equal)
- Are **self-validating** (cannot exist in invalid state)
- Have **no side effects** (pure logic only)

### Why Value Objects?

**Before Value Objects:**
```typescript
// âŒ Duplicate validation everywhere
class Project {
  create(params) {
    if (params.startDate >= params.endDate) {
      return { success: false, errors: ['End must be after start'] };
    }
    // ... 150 lines of date range validation duplicated across entities
  }
}

class Phase {
  create(params) {
    if (params.startDate >= params.endDate) { // Duplicate!
      return { success: false, errors: ['End must be after start'] };
    }
  }
}
```

**After Value Objects:**
```typescript
// âœ… Validation in one place
class DateRange {
  static create(start: Date, end: Date): DomainResult<DateRange> {
    if (start >= end) {
      return { success: false, errors: ['End must be after start'] };
    }
    return { success: true, data: new DateRange(start, end) };
  }
  
  overlaps(other: DateRange): boolean { /* ... */ }
  getDurationInDays(): number { /* ... */ }
}

// Entities use value objects
class Project {
  private _dateRange: DateRange;
  
  static create(params) {
    const rangeResult = DateRange.create(params.startDate, params.endDate);
    if (!rangeResult.success) return rangeResult;
    // ... validation done, use the value object
  }
}
```

### Our Value Objects

**Implemented (December 2025):**
```
src/domain/value-objects/
â”œâ”€â”€ DateRange.ts       â†’ Date range validation, overlap detection, duration
â”œâ”€â”€ EmailAddress.ts    â†’ Email validation and formatting
â”œâ”€â”€ PhoneNumber.ts     â†’ Phone validation and formatting
â”œâ”€â”€ Color.ts           â†’ Hex color validation and manipulation
â””â”€â”€ index.ts           â†’ Barrel export
```

**Usage:**
- **DateRange**: Used by Project, Phase, Holiday entities (~150 lines duplication removed)
- **EmailAddress**: Used by Client entity (email validation)
- **PhoneNumber**: Used by Client entity (phone validation)
- **Color**: Used by Project, Phase, Label entities (color validation + HSL/RGB conversion)

**Integration Status:** Created but not yet integrated into entities (gradual adoption)

### Value Objects vs Entities

| Aspect | Value Object | Entity |
|--------|-------------|--------|
| **Identity** | Defined by value | Has unique ID |
| **Mutability** | Immutable | Can change over time |
| **Equality** | Two with same value are equal | Two with same ID are equal |
| **Lifecycle** | No lifecycle (just created/discarded) | Tracked lifecycle (create/update/delete) |
| **Examples** | DateRange, EmailAddress, Money | Project, Client, Phase |

**Key Rule:** If you can replace it with an identical copy and nobody would notice, it's a Value Object.

---

## Domain Services - Migration Complete (January 2026)

### âœ… Migration Complete

**Domain services have been MERGED into `domain/rules/`** as part of the three-layer simplification.

| Previous Location | Current Location | Status |
|-------------------|------------------|--------|
| `domain/domain-services/PhaseRecurrenceService.ts` | `domain/rules/phases/PhaseRecurrence.ts` | âœ… MERGED |
| `domain/domain-services/ProjectBudgetService.ts` | `domain/rules/projects/ProjectBudget.ts` | âœ… MERGED |
| `domain/domain-services/PhaseDistributionService.ts` | `domain/rules/phases/PhaseDistribution.ts` | âœ… MERGED |

**Why we merged:**
- Same purity guarantees (no UI, no DB)
- Fewer folders to navigate
- One answer to "where does business logic go?"
- Calculations stay co-located with validation

### What Are Domain Services?

**Domain Services** contain pure domain logic that doesn't naturally fit within a single entity. They are:
- **Stateless** (no internal state)
- **Pure functions** (no side effects, no dependencies)
- **Domain-focused** (no persistence, no UI)
- **Reusable** (shared across entities and orchestrators)

### Current Domain Services (Being Migrated)

**Implemented (December 2025) â†’ Migrating to domain/rules/ (January 2026):**
```
âš ï¸ CURRENT (src/domain/domain-services/):
â”œâ”€â”€ PhaseRecurrenceService.ts   â†’ Recurring phase patterns (~430 lines)
â”œâ”€â”€ ProjectBudgetService.ts     â†’ Budget analysis (~400 lines)
â”œâ”€â”€ PhaseDistributionService.ts â†’ Time distribution (~460 lines)
â””â”€â”€ index.ts                    â†’ Barrel export

âœ… TARGET (src/domain/rules/):
â”œâ”€â”€ phases/
â”‚   â”œâ”€â”€ PhaseRecurrence.ts      â† From PhaseRecurrenceService
â”‚   â”œâ”€â”€ PhaseDistribution.ts    â† From PhaseDistributionService
â”‚   â””â”€â”€ PhaseBudget.ts
â”œâ”€â”€ projects/
â”‚   â””â”€â”€ ProjectBudget.ts        â† From ProjectBudgetService
â””â”€â”€ sync/
    â”œâ”€â”€ DateSync.ts             â† Cross-cutting date logic
    â””â”€â”€ BudgetSync.ts           â† Cross-cutting budget logic
```

**1. PhaseRecurrenceService** â†’ `domain/rules/phases/PhaseRecurrence.ts`:
```typescript
// Validate recurring pattern
PhaseRecurrence.validateConfig(true, config, 8);

// Generate occurrence dates (inline rrule math)
PhaseRecurrence.generateOccurrences({
  config: { type: 'weekly', interval: 2, weeklyDayOfWeek: 1 },
  projectStartDate, projectEndDate
});

// Human description
PhaseRecurrence.getDescription(config);
// "Every 2 weeks on Monday"
```

**2. ProjectBudgetService** â†’ `domain/rules/projects/ProjectBudget.ts`:
```typescript
// Check budget status (inline budget math)
ProjectBudget.checkConstraint(phases, 100);
// { isValid: true, totalAllocated: 85, remaining: 15, ... }

// Comprehensive analysis
ProjectBudget.analyze(phases, projectBudget);
// { recommendations: [...], isOverBudget: false, ... }
```

**3. PhaseDistributionService** â†’ `domain/rules/phases/PhaseDistribution.ts`:
```typescript
// Allocation statistics (inline math)
PhaseDistribution.calculateAllocationDistribution(phases);
// { min, max, avg, median, standardDeviation }

// Spacing recommendations
PhaseDistribution.generateSpacingRecommendation(start, end, currentCount);
// { recommendedDates: [...], intervalDays: 7, reasoning: "..." }
```

### Key Principle: Math Inline

**Before (separate utilities):**
```typescript
import { DateMath } from '@/utils/math';
const days = DateMath.daysBetween(start, end);
```

**After (inline with business logic):**
```typescript
// In domain/rules/phases/PhaseDistribution.ts
const days = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
```

**Why?** Calculations belong with the business logic that uses them. Extracting to utilities creates indirection without value.

---

## Key Architectural Decisions

### 1. Three-Layer Documentation Model

**App Logic** (`/src/domain/App Logic.md`) defines WHAT exists (domain truth):
- "Projects have three time types: auto-estimated, planned, completed"
- "All time types coexist in the domain simultaneously"

**Business Rules** (`/src/domain/Business Rules.md`) defines HOW calculations work (domain rules):
- "Auto-estimate = (Remaining Hours) Ã· (Days without events)"
- "Events exclude days from auto-estimate distribution"

**Display Logic** (`/src/domain/Display Logic.md`) defines WHERE display constraints apply:
- "Timeline View shows only ONE time type per day (mutual exclusivity)"
- "Calendar View can show multiple time types (no overlap constraint)"

### 2. Domain Truth vs UI Constraints

**Example: Rule 9 (Daily Time Allocation)**

**Domain Truth** (Business Rules):
- Auto-estimated, planned, and completed time all exist
- Calculations run regardless of display
- All time types are always available

**Display Constraint** (Display Logic):
- Timeline bars can't overlap visually
- Display only ONE type per day in Timeline View
- Same data shown differently in Calendar View

### 3. No Repository Layer

**Why:** Supabase already provides:
- Type-safe queries
- Row-level security
- Real-time subscriptions
- Query builder

Adding repositories would create:
- Wrapper methods that just delegate
- Extra abstraction with no value
- Development slowdown

**Pattern:**
```typescript
// âœ… Direct Supabase (our approach)
const { data } = await supabase.from('projects').select('*');

// âŒ Repository wrapper (unnecessary)
const data = await projectRepository.findAll();
```

---

## Migration Path: Moving to Strict DDD

**When to Consider:**
- Team grows beyond 5-7 developers
- Domain logic leaking into orchestrators becomes painful
- Multiple clients need same backend (API reuse)
- Testing becomes difficult due to mixed concerns

### Phase 1 (Current) â†’ Phase 2 (Strict DDD)

**What Changes:**

### 1. Add Repository Layer (3-4 weeks)

**Current:**
```typescript
// Orchestrators call Supabase directly
await supabase.from('projects').insert(data);
```

**Strict DDD:**
```typescript
// Orchestrators call repositories
await projectRepository.create(data);

// repositories/ProjectRepository.ts
class ProjectRepository {
  async create(data: Project): Promise<Project> {
    return await supabase.from('projects').insert(data);
  }
}
```

**Effort:** 
- Create repository for each entity (9 files)
- Update all orchestrator calls
- Add repository tests

### 2. Extract Presentation Logic (2-3 weeks)

**Current:**
```typescript
// Orchestrators mix app + presentation
class ProjectOrchestrator {
  async createProject(data) {
    const dbData = this.transformForDatabase(data); // Presentation
    const project = await supabase.insert(dbData);
    return this.enrichForDisplay(project); // Presentation
  }
}
```

**Strict DDD:**
```typescript
// Application Services (pure app logic)
class ProjectApplicationService {
  async createProject(data: CreateProjectInput) {
    const validation = ProjectRules.validate(data);
    const project = await projectRepository.create(data);
    return project; // Pure entity
  }
}

// Presentation Adapters (UI prep)
class ProjectPresentationAdapter {
  static enrichForDisplay(project: Project) {
    return { ...project, displayColor: ... };
  }
}
```

**Effort:**
- Create application services layer (9 files)
- Create presentation adapters layer (new folder)
- Migrate all orchestrator logic
- Update component imports

### 3. Enforce Entity Usage (1-2 weeks)

**Current:**
```typescript
// Orchestrators work with plain data
const project = { id: '123', name: 'Test' };
```

**Strict DDD:**
```typescript
// Everything uses entity instances
const project = Project.create({ name: 'Test' });
if (!project.success) return project.errors;

const entity = project.data; // Always a Project instance
entity.isActiveOnDate(today); // Use entity methods
```

**Effort:**
- Update all orchestrators to use entities
- Update all unified services to accept entities
- Ensure entities used in components

### 4. Update Documentation (1 week)

**Effort:**
- Update `.architecture` with new layers
- Document repository patterns
- Update AI decision matrix
- Add migration notes

---

## Total Migration Estimate

**Time:** 8-12 weeks (depending on team size)

**Breakdown:**
- Week 1-4: Repository layer + tests
- Week 5-7: Extract presentation logic
- Week 8-9: Enforce entity usage everywhere
- Week 10-11: Update documentation
- Week 12: Buffer for issues

**Risk:** Medium (no breaking changes, gradual migration possible)

**Benefit:** Full code-level layer separation, easier testing, API reuse

---

## Future DDD Building Blocks (May Add Later)

These are standard DDD patterns we may adopt when needed:

### Domain Events (`domain/domain-events/`) - NOT YET IMPLEMENTED  
- **Purpose:** Things that happened in the domain
- **Example:** ProjectCreated, PhaseCompleted events
- **Status:** Not needed yet
- **Trigger:** When need to decouple side effects (notifications, integrations)

### Aggregates (`domain/aggregates/`) - NOT YET IMPLEMENTED
- **Purpose:** Cluster of entities treated as a single unit
- **Example:** Project + Phases as ProjectAggregate
- **Status:** Entities work independently
- **Trigger:** When complex transaction boundaries needed

**Note:** These can be added incrementally without major refactoring.

---

## Decision: Three-Layer Simplification (January 2026) - COMPLETE

**Previous State (December 2025):**
- Business logic in 5+ locations (rules, domain-services, unified, calculations, orchestrators)
- "Where does this go?" had multiple correct answers
- Good purity, but too many folders

**Current State (January 2026) - âœ… COMPLETE:**
- Simplified to THREE clear layers
- ALL business logic in ONE place (domain/rules/)
- Clear, enforced hierarchy

**Current Architecture:**
```
Layer 1: domain/rules/           â† ALL business logic (validation + calculations inline)
Layer 2: services/               â† Application services (4 subdirectories)
         â”œâ”€â”€ orchestrators/      â† Workflows (coordination only)
         â”œâ”€â”€ data/               â† Transformation + aggregation
         â”œâ”€â”€ infrastructure/     â† Error handling, storage, caching
         â””â”€â”€ ui/                 â† View positioning & layout
Layer 3: components/             â† React UI
         â”œâ”€â”€ shadcn/             â† Design system (shadcn/ui)
         â”œâ”€â”€ features/
         â”œâ”€â”€ views/
         â””â”€â”€ shared/
```

**Key Changes:**
| What | From | To | Status |
|------|------|-----|--------|
| Domain Services | `domain/domain-services/` | `domain/rules/` | âœ… MERGED |
| Calculations | `services/calculations/` | `domain/rules/` (inline) | âœ… MERGED |
| Unified Services | `services/unified/` | `domain/rules/` + `services/data/` | âœ… SPLIT |
| Math Utilities | Separate files | Inline with business logic | âœ… DONE |
| Infrastructure | `/infrastructure/` | `services/infrastructure/` | âœ… MOVED |
| UI Services | `/ui/` | `services/ui/` | âœ… MOVED |
| Shadcn Components | `components/ui/` | `components/shadcn/` | âœ… RENAMED |

**Progress (January 2026) - âœ… SUBSTANTIALLY COMPLETE:**
- âœ… Architecture plan created
- âœ… Audit completed (documented bypass of domain rules)
- âœ… Three-layer structure designed and implemented
- âœ… Domain-services merged into rules/
- âœ… Calculations merged into rules/ (inline)
- âœ… Unified services deleted (split into rules/ + data/)
- âœ… Infrastructure consolidated into services/infrastructure/
- âœ… UI services consolidated into services/ui/
- âœ… Components/ui renamed to components/shadcn/
- â³ Future: Further consolidation of domain/rules/ subdirectories (optional)

**Review Triggers for Strict DDD:**
- Team grows beyond 7 developers
- Need to build separate API/mobile client
- Testing becomes difficult with current structure

---

## Quick Reference

**Current Architecture (Three-Layer Hybrid DDD) - âœ… IMPLEMENTED:**
```
Components â†’ Orchestrators (coordination) â†’ Domain Rules (ALL business logic)
                      â†“
               Data Services (transformation only)
                      â†“
               Supabase (direct calls)

Domain Layer (Pure):
  domain/
  â”œâ”€â”€ rules/                        â† ALL business logic
  â”‚   â”œâ”€â”€ phases/
  â”‚   â”œâ”€â”€ projects/
  â”‚   â”œâ”€â”€ sync/                     â† Cross-cutting
  â”‚   â”œâ”€â”€ events/
  â”‚   â”œâ”€â”€ availability/
  â”‚   â””â”€â”€ ... (18 subdirectories)
  â”œâ”€â”€ entities/                     â† Rich domain models
  â””â”€â”€ value-objects/                â† Immutable primitives

Services Layer (Application):
  services/
  â”œâ”€â”€ orchestrators/                â† Workflows (coordination ONLY)
  â”œâ”€â”€ data/                         â† Data transformation
  â”‚   â”œâ”€â”€ mappers/
  â”‚   â””â”€â”€ aggregators/
  â”œâ”€â”€ infrastructure/               â† Error, storage, caching
  â””â”€â”€ ui/                           â† View positioning & layout

Components Layer (UI):
  components/
  â”œâ”€â”€ shadcn/                       â† Design system
  â”œâ”€â”€ features/
  â”œâ”€â”€ views/
  â””â”€â”€ shared/
```

**Documentation (Never Changes):**
```
App Logic.md â†’ Business Rules.md â†’ Display Logic.md
(Pure domain truth, regardless of code approach)
```

---

**Bottom Line:** We simplified from 5+ overlapping layers to 3 clear layers with ONE answer to "where does this go?"
