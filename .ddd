# Architectural Philosophy: Pragmatic DDD

**Last Updated:** January 9, 2026  
**Status:** ✅ Implemented and operational

---

## Our Philosophy: Purity Where It Matters, Pragmatism Where It Helps

This codebase follows **Pragmatic Domain-Driven Design** - prioritizing **business logic isolation** and **development velocity** over architectural purity for its own sake.

### The Core Bet

**We believe:**
- Business logic should be completely isolated from UI and infrastructure
- Complex workflows benefit from direct pragmatic implementation over abstraction layers
- Clear documentation provides architectural clarity as effectively as code separation
- Velocity matters - optimize for speed of development and ease of understanding

**We don't believe:**
- Every layer needs complete code isolation to maintain boundaries
- Repositories add value when the database already provides type safety
- Extracting every calculation into utilities improves maintainability
- Full DDD purity is worth the development overhead for this project

### In Practice

**Domain Layer (100% Pure):**
Business logic in `domain/` is completely isolated - no UI, no database, no external dependencies. Non-negotiable because:
- Business rules should be testable in isolation
- Domain logic should be portable (API, mobile, CLI)
- Business logic changes frequently - must be easy to find and modify

**Application Layer (Pragmatically Mixed):**
Orchestrators in `application/` intentionally mix concerns - coordinate domain logic, make database calls, transform data, handle side effects. Pragmatic because:
- Supabase already provides type safety, query building, and RLS
- Direct, readable code over abstraction layers
- Repository/service/adapter layers would just create delegation wrappers

**Result:** Fast iteration, clear boundaries where they matter, pragmatic implementation where abstraction adds no value.

---

## Current Architecture: 4-Layer DDD

```
src/
├── domain/                         ← Pure business logic (NO UI, NO DB)
│   ├── rules/                      ← ALL business rules & calculations
│   ├── entities/                   ← Rich domain models
│   └── value-objects/              ← Immutable primitives
│
├── application/                    ← Use case orchestrators
│   ├── orchestrators/              ← Workflows (coordination ONLY)
│   └── queries/                    ← Read-side queries
│
├── infrastructure/                 ← External dependencies
│   ├── database/                   ← Supabase client
│   ├── errors/                     ← Error handling
│   └── caching/                    ← Performance optimization
│
├── presentation/                   ← UI layer (React)
│   ├── components/                 ← React components
│   ├── hooks/                      ← React hooks
│   ├── contexts/                   ← React contexts
│   └── pages/                      ← Page components
│
├── shared/                         ← Cross-cutting concerns
│   ├── types/                      ← TypeScript types
│   └── assets/                     ← Static files
│
└── website/                        ← Public marketing pages
```

---

## Layer Responsibilities

### Domain Layer (Pure) - Sacred Boundary

**What:** Core business logic, completely isolated from UI and infrastructure.

**Structure:**
- **`rules/`** - ALL business logic (validation, calculations, constraints)
  - Organized by domain concept (`phases/`, `projects/`, `events/`, `sync/`)
  - Math calculations inline with business logic
- **`entities/`** - Rich domain models with behavior (not anemic data containers)
- **`value-objects/`** - Immutable primitives (DateRange, EmailAddress, Color)

**Hard Rules:**
- ❌ NO UI references (not even "timeline" or "calendar" in names)
- ❌ NO database/persistence logic
- ❌ NO external dependencies
- ✅ Pure functions only
- ✅ 100% testable in isolation

**Why Pure:**
- Testable without mocking (input → function → assert)
- Portable (could use in Node.js, mobile, CLI)
- Business logic in one place (easy to find, easy to change)

---

### Application Layer (Orchestration) - Pragmatic

**What:** Coordinates domain logic with infrastructure to fulfill use cases.

**Structure:**
- **`orchestrators/`** - Workflows (CREATE/UPDATE/DELETE)
  - Call domain rules for validation/calculations
  - Direct Supabase access (no repository layer)
  - Transform data using mappers
  - Coordinate side effects
- **`queries/`** - Read-side operations and data aggregation

**Rules:**
- ❌ NO business logic (goes in `domain/rules/`)
- ✅ Call domain rules for validation/calculations
- ✅ Direct Supabase access (we embrace this)
- ✅ Transform data for UI presentation

**Why Pragmatic:**
If we change databases, we rewrite migrations, RLS policies, and query patterns anyway. Repositories would just add another layer to update with no reduction in change cost.

---

### Infrastructure Layer (External) - Technical Plumbing

**What:** External dependencies and technical concerns.

**Structure:**
- **`database/`** - Supabase client configuration
- **`errors/`** - Error handling (uses dependency injection for UI dependencies)
- **`caching/`** - Performance optimization

**Rules:**
- ❌ NO business logic
- ❌ NO direct imports from presentation (use dependency injection)
- ✅ External integrations
- ✅ Technical cross-cutting concerns

**Key Pattern - Dependency Injection:**
```typescript
// Infrastructure can't import presentation (circular dependency)
// Inject dependencies at app initialization

// infrastructure/errors/ErrorHandlingService.ts
class ErrorHandlingService {
  private static toastFn: ToastFunction | null = null;
  
  static setToastFunction(fn: ToastFunction) {
    this.toastFn = fn;
  }
}

// App.tsx
ErrorHandlingService.setToastFunction(toast);
```

---

### Presentation Layer (UI) - React & User Interface

**What:** React components, hooks, and UI-specific logic.

**Structure:**
- **`components/`** - React UI components (`shadcn/`, `features/`, `views/`, `shared/`)
- **`hooks/`** - React hooks (`data/` for fetching, `ui/` for UI logic)
- **`contexts/`** - React contexts (see data loading strategy below)

**Data Loading Strategy:**

We evolved from "God Contexts" (loading ALL data for everyone) to a more nuanced approach:

**Use Contexts For:**
- ✅ **Global UI state** - Auth, settings, selected project (needed everywhere)
- ✅ **Scoped data with painful prop-drilling** - Data needed by 5+ nested components

**Use Parent Loading + Props For:**
- ✅ **View-scoped shared data** - Multiple children need similar data
```typescript
// Parent loads once, children receive via props
function InsightsView() {
  const { events, isLoading } = useEvents({ startDate, endDate });
  
  if (isLoading) return <LoadingSpinner />;
  
  return (
    <>
      <TimeDistributionCard events={events} />
      <ProjectBreakdownCard events={events} />
      <TrendAnalysisCard events={events} />
    </>
  );
}
```

**Use Component Loading For:**
- ✅ **Component-specific data** - Needs different data than siblings
- ✅ **Reusable components** - Used in multiple contexts with different requirements

**Benefits:**
- Coordinated UX (one loading state for related components)
- Right-sized data (load exactly what's needed)
- Explicit data flow (props show dependencies)
- Performance (avoid redundant queries)

**Rules:**
- ❌ NO business logic (goes in `domain/rules/`)
- ❌ NO global "God Contexts" loading all data
- ✅ Prefer props over context when possible (explicit > implicit)
- ✅ Components call orchestrators directly for CRUD

---

## Key Architectural Decisions

### 1. No Repository Layer

**Traditional DDD:** "Abstract database behind repositories."

**We say:** Supabase already provides type safety, query building, RLS. Repositories would create wrapper methods that just delegate with no added value.

**If we change databases:** Migrations, RLS policies, query patterns all need rewriting anyway. Repositories don't reduce this cost.

---

### 2. Calculations Inline with Business Rules

**Traditional:** Extract to `utils/dateUtils.ts`, `utils/mathUtils.ts`.

**We say:** Business calculations belong with the business rules that use them.

**Why:** When debugging budget allocation, you want to see the business rule, calculation, and validation together in one file.

**When we extract:** Only when the same calculation appears in 3+ domain concepts.

---

### 3. Dependency Injection for Cross-Layer Dependencies

**Why:** Prevents circular dependencies (e.g., ErrorHandlingService needs toast from UI, but UI needs ErrorHandlingService).

**Pattern:** Infrastructure provides setter, presentation injects at app initialization.

---

### 4. Data Loading Strategy - Context vs Props vs Component

**Problem we solved:** 757-line `PlannerContext` loaded ALL events (1000+) for every view, throwing away 95%+ of data.

**Solution:** Nuanced approach based on scope and needs:
- Global UI state → Context
- View-scoped shared data → Parent loads, pass props
- Component-specific data → Component loads via hooks
- Deep prop-drilling (5+ levels) → Consider scoped context

**Result:** 10-20x performance, coordinated UX, right-sized data.

---

### 5. Website Separated from App

**Why:** Marketing pages (SEO, copy, auth) have different concerns than the app (business logic, real-time, workflows).

**Benefits:** Clear public/private boundary, independent deployment, different change frequencies.

---

## Design Principles

### Purity Principle: Protect the Domain

Domain layer is **sacred**. Must stay pure for:
- Portability (can extract to CLI, mobile, API)
- Testability (pure functions, no mocking)
- Change velocity (business logic in one place)
- Onboarding (understand business without learning frameworks)

**Rule:** If it depends on React/Supabase/any external library → NOT domain layer.

---

### Pragmatism Principle: Optimize for Velocity

Outside domain, optimize for development velocity over architectural purity.

**Decision Rule Before Adding Abstraction:**
1. Does this protect the domain layer? → If yes, do it
2. Does this reduce future change cost by >50%? → If yes, consider
3. Does this make code easier to understand today? → If yes, consider
4. Is this abstraction for its own sake? → If yes, skip it

**Examples:**
- Repositories? No. (Database change cost is in migrations, not abstraction)
- Math utilities? No. (Calculations belong with business logic)
- Strict layer isolation? No. (YAGNI - not building API today)

---

### Documentation Principle: Clarity Through Words

Clear documentation provides architectural clarity as effectively as code separation.

**Three-Layer Documentation:**
1. **App Logic** (`domain/App Logic.md`) - WHAT exists (domain truth)
2. **Business Rules** (`domain/Business Rules.md`) - HOW calculations work
3. **Display Logic** (`presentation/components/README.md`) - WHERE UI constraints apply

**Why:** Explains "why" not just "what". Helps developers and AI understand philosophy without reading every file.

---

### Velocity Principle: Ship Fast, Refactor Later

Better to ship working software with pragmatic architecture than spend weeks on perfect abstraction.

**YAGNI:** Will we swap databases? Build API? Extract domain package? Probably not soon. Don't build abstraction for maybes.

**Refactoring is cheap:** Adding repositories later: 2-3 weeks. Building/maintaining them now: 6+ months overhead.

**Decision:** Invest in domain purity (high value, hard to refactor later). Ship pragmatic infrastructure (low value, easy to refactor later).

---

## Quick Reference

**"Where does this code go?"**

| Code Type | Location | Example |
|-----------|----------|---------|
| Business validation | `domain/rules/` | Phase date validation |
| Business calculation | `domain/rules/` | Budget allocation |
| Domain model | `domain/entities/` | Project, Phase, Event |
| Immutable primitive | `domain/value-objects/` | DateRange, EmailAddress |
| Workflow/CRUD | `application/orchestrators/` | createProject, updatePhase |
| Data query | `application/queries/` | getProjectsWithPhases |
| Database client | `infrastructure/database/` | Supabase config |
| Error handling | `infrastructure/errors/` | ErrorHandlingService |
| React component | `presentation/components/` | ProjectCard, EventModal |
| React hook | `presentation/hooks/` | useEvents, useProjects |
| Global UI state | `presentation/contexts/` | AuthContext, SettingsContext |
| Shared type | `shared/types/` | TypeScript interfaces |

**"When to use Context vs Props vs Component Loading?"**

| Scenario | Pattern | Example |
|----------|---------|---------|
| Needed everywhere | Global Context | Auth state, user preferences |
| Shared by 3-5 children | Parent loads → Props | InsightsView loads events, cards receive them |
| Deep prop-drilling (5+ levels) | Scoped Context | TimelineDataContext for timeline feature |
| Component-specific needs | Component loads via hook | Modal needs different data than view |

---

## Testing

**Coverage:** 547 tests (Domain: 90%, Entities: 60%, Orchestrators: 75%, Utils: 85%)

Tests co-located in `__tests__/` directories. Focus on domain layer (pure, critical logic).

---

## Bottom Line

**What We Built:**
4-layer DDD architecture that protects business logic while shipping fast.

**Core Beliefs:**
1. Domain purity is non-negotiable (business logic isolated, testable, portable)
2. Infrastructure abstraction is optional (build when pain > cost)
3. Documentation provides clarity (explain "why")
4. Velocity enables learning (ship fast, refactor based on real pain)

**The Result:**
```
Pure Domain (business logic isolated)
    ↓
Pragmatic Application (direct database access)
    ↓
Thin Infrastructure (minimal abstraction)
    ↓
Focused Presentation (nuanced data loading strategy)
```

**When to Reconsider:**
- Team grows beyond 10 developers → Stricter layer isolation
- Need to build public API → Add service layer
- Database change becomes likely → Add repositories
- Domain logic leaking into orchestrators → Tighten boundaries

**Until then:** Protect domain purity, ship pragmatic infrastructure, document reasoning, iterate based on user feedback.

---

**Philosophy in One Sentence:**
*Protect the domain layer completely, pragmatically mix everything else, document the reasoning.*
