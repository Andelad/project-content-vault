# Architecture Philosophy: Hybrid DDD

**Last Updated:** January 7, 2026  
**Current Approach:** Hybrid Domain-Driven Design (DDD) - Three-Layer Simplification  
**Migration Status:** In Progress - See `/docs/operations/ARCHITECTURE_REBUILD_PLAN.md`

---

## üöß ARCHITECTURE SIMPLIFICATION (January 2026)

### The Problem We're Solving

Business logic was scattered across 5+ layers:
- `domain/rules/` (validation)
- `domain/domain-services/` (pure algorithms)
- `services/unified/` (mixed logic + data)
- `services/calculations/` (pure math)
- `services/orchestrators/` (coordination + logic leakage)

**Result:** "Where does this go?" had multiple correct answers.

### The Solution: Three Clear Layers

```
üìê Target Architecture (THREE LAYERS):

Layer 1: domain/rules/              ‚Üê ALL business logic (validation + calculations)
‚îú‚îÄ‚îÄ phases/                         ‚Üê Phase rules organized by concern
‚îÇ   ‚îú‚îÄ‚îÄ PhaseValidation.ts
‚îÇ   ‚îú‚îÄ‚îÄ PhaseRecurrence.ts          ‚Üê (merged from domain-services)
‚îÇ   ‚îú‚îÄ‚îÄ PhaseDistribution.ts        ‚Üê (merged from domain-services)
‚îÇ   ‚îú‚îÄ‚îÄ PhaseBudget.ts              ‚Üê (merged from domain-services)
‚îÇ   ‚îî‚îÄ‚îÄ PhaseHierarchy.ts
‚îú‚îÄ‚îÄ projects/                       ‚Üê Project rules organized by concern
‚îÇ   ‚îú‚îÄ‚îÄ ProjectValidation.ts
‚îÇ   ‚îú‚îÄ‚îÄ ProjectBudget.ts            ‚Üê (merged from domain-services)
‚îÇ   ‚îú‚îÄ‚îÄ ProjectPhaseManager.ts
‚îÇ   ‚îî‚îÄ‚îÄ ProjectHierarchy.ts
‚îú‚îÄ‚îÄ sync/                           ‚Üê Cross-cutting concerns
‚îÇ   ‚îú‚îÄ‚îÄ DateSync.ts                 ‚Üê Phase/project date synchronization
‚îÇ   ‚îî‚îÄ‚îÄ BudgetSync.ts               ‚Üê Phase/project budget synchronization
‚îú‚îÄ‚îÄ calendar-events/
‚îú‚îÄ‚îÄ holidays/
‚îú‚îÄ‚îÄ feedback/
‚îú‚îÄ‚îÄ clients/
‚îú‚îÄ‚îÄ time-tracker/
‚îî‚îÄ‚îÄ notifications/

Layer 2: services/orchestrators/    ‚Üê Workflows only (NO business logic)
‚îú‚îÄ‚îÄ PhaseOrchestrator.ts            ‚Üê Calls rules, coordinates DB + UI
‚îú‚îÄ‚îÄ ProjectOrchestrator.ts
‚îú‚îÄ‚îÄ CalendarEventOrchestrator.ts
‚îî‚îÄ‚îÄ ...

Layer 3: services/data/             ‚Üê Data transformation only (NO business logic)
‚îú‚îÄ‚îÄ mappers/                        ‚Üê DB‚ÜîUI field translation
‚îÇ   ‚îú‚îÄ‚îÄ PhaseMapper.ts
‚îÇ   ‚îî‚îÄ‚îÄ ProjectMapper.ts
‚îî‚îÄ‚îÄ aggregators/                    ‚Üê Multi-table queries
    ‚îú‚îÄ‚îÄ PhaseAggregator.ts
    ‚îî‚îÄ‚îÄ ProjectAggregator.ts
```

### Key Decisions (January 7, 2026)

| Decision | Rationale |
|----------|-----------|
| **Merge domain-services ‚Üí rules** | Same purity, fewer folders to navigate |
| **NO MathUtils** | Keep calculations inline with business logic |
| **NO separate calculations layer** | Math belongs with the rules that use it |
| **Split unified services** | Business logic ‚Üí rules, data transformation ‚Üí services/data |
| **Cross-cutting in sync/** | Explicit home for phase‚Üîproject interactions |

### What Gets Deleted

```
‚ùå domain/domain-services/          ‚Üí Merged into domain/rules/
‚ùå services/calculations/           ‚Üí Merged into domain/rules/
‚ùå services/unified/                ‚Üí Split: logic‚Üírules, data‚Üíservices/data/
```

### Migration Status

See `/docs/operations/ARCHITECTURE_REBUILD_PLAN.md` for detailed progress.

---

## Our Current Philosophy: Hybrid DDD

### What We Do

**Pure Documentation, Pragmatic Code**

We maintain **strict separation in documentation** while allowing **pragmatic mixing in code**:

```
üìö Documentation (Co-located with Code):
‚îú‚îÄ‚îÄ /.architecture              ‚Üí Overall architecture philosophy
‚îú‚îÄ‚îÄ /.ddd                   ‚Üí This file - Hybrid DDD evolution
‚îú‚îÄ‚îÄ /src/domain/
‚îÇ   ‚îú‚îÄ‚îÄ Domain Logic.md         ‚Üí Domain concepts (100% UI-agnostic)
‚îÇ   ‚îú‚îÄ‚îÄ Rules Logic.md          ‚Üí Domain rules & calculations (UI-agnostic)
‚îÇ   ‚îî‚îÄ‚îÄ Display Logic.md        ‚Üí Display-specific business rules
‚îî‚îÄ‚îÄ /src/components/
    ‚îî‚îÄ‚îÄ README.md               ‚Üí Component organization

üíª Code (Three Layers - Target State):
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ entities/        ‚Üí Rich domain models ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ rules/           ‚Üí ALL business logic (validation + calculations) ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ value-objects/   ‚Üí Immutable domain primitives ‚úÖ
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ orchestrators/   ‚Üí Workflows only (NO logic) ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ data/            ‚Üí Transformation + aggregation ‚úÖ
‚îî‚îÄ‚îÄ components/          ‚Üí UI display ‚úÖ

üíª Code (Current State - Being Migrated):
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ entities/        ‚Üí Rich domain models ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ rules/           ‚Üí Validation + some business logic ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ value-objects/   ‚Üí Immutable domain primitives ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ domain-services/ ‚Üí Pure algorithms ‚ö†Ô∏è MIGRATING ‚Üí rules/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ orchestrators/   ‚Üí Workflows (some logic leakage) ‚ö†Ô∏è
‚îÇ   ‚îú‚îÄ‚îÄ unified/         ‚Üí Mixed concerns ‚ö†Ô∏è MIGRATING ‚Üí rules/ + data/
‚îÇ   ‚îú‚îÄ‚îÄ calculations/    ‚Üí Pure math ‚ö†Ô∏è MIGRATING ‚Üí rules/
‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/  ‚Üí Cross-cutting concerns ‚úÖ
‚îî‚îÄ‚îÄ components/          ‚Üí UI display ‚úÖ
```

**Key Principle:** Documentation lives near the code it describes.
- All domain documentation together in `/src/domain/`
- Component organization in `/src/components/`
- Architecture at project root (alongside `.cursorrules`)

### Where We Stay Pure

**Domain Layer** (`domain/`) - Never compromise:

1. **Entities** (`domain/entities/`) - Things with identity:
   - ‚úÖ Encapsulate state + behavior
   - ‚úÖ Validate on construction
   - ‚úÖ Self-contained business logic
   - ‚ùå NO UI concerns

2. **Value Objects** (`domain/value-objects/`) - Primitive concepts:
   - ‚úÖ Immutable by design
   - ‚úÖ Self-validating
   - ‚úÖ Defined by value, not identity
   - ‚úÖ Examples: DateRange, EmailAddress, PhoneNumber, Color
   - ‚ùå NO side effects

3. **Rules** (`domain/rules/`) - ALL business logic (validation + calculations):
   - ‚úÖ Pure business rules
   - ‚úÖ Calculations inline (no separate math utilities)
   - ‚úÖ Organized by concern (phases/, projects/, sync/)
   - ‚ùå NO UI references ("timeline", "calendar", "view")
   - ‚ùå NO persistence logic
   - ‚ùå NO presentation logic

### Where We Mix (Intentionally)

**Orchestrators** (`services/orchestrators/`) - Pragmatic glue layer:
- ‚úÖ Application workflows (CREATE/UPDATE/DELETE)
- ‚úÖ Call domain rules (PhaseValidation.validate(), DateSync.synchronize())
- ‚úÖ Direct database access (supabase.from()... - NO repository layer)
- ‚úÖ Use data mappers for transformation
- ‚úÖ Enrich for UI display (presentation prep)
- ‚úÖ Coordinate side effects (notifications, updates)
- ‚ùå NO business logic (goes in domain/rules/)
- ‚ùå NO calculations (goes in domain/rules/ inline)

**Example:**
```typescript
async createProject(data: CreateProjectInput) {
  // ‚úÖ Call domain rules (validation + calculations)
  const validation = ProjectValidation.validateCreate(data);
  if (!validation.isValid) return validation;
  
  // ‚úÖ Use data mapper for DB transformation
  const dbData = ProjectMapper.toDatabase(data);
  
  // ‚úÖ Direct DB access (no repository layer)
  const { data: project } = await supabase.from('projects').insert(dbData).select().single();
  
  // ‚úÖ Use data mapper for UI transformation
  return ProjectMapper.fromDatabase(project);
}
```

### Why Hybrid?

**Velocity vs Purity Trade-off:**

| Aspect | Strict DDD | Hybrid DDD (Our Choice) |
|--------|-----------|-------------------------|
| **Layer Separation** | 100% code separation | Pure domain, mixed orchestrators |
| **Repository Layer** | Required abstraction | Direct Supabase calls |
| **Entity Usage** | Everywhere | Domain layer only |
| **Development Speed** | Slower (more abstraction) | Faster (pragmatic) |
| **Maintenance Clarity** | Code self-documents | Documentation self-documents |

**Our Bet:** Clear documentation + simple three-layer structure provides architectural clarity faster than full code separation.

---

## Value Objects (Added December 2025)

### What Are Value Objects?

**Value Objects** represent primitive domain concepts that:
- Are **immutable** (cannot change after creation)
- Are defined by their **value**, not identity (two DateRanges with same dates are equal)
- Are **self-validating** (cannot exist in invalid state)
- Have **no side effects** (pure logic only)

### Why Value Objects?

**Before Value Objects:**
```typescript
// ‚ùå Duplicate validation everywhere
class Project {
  create(params) {
    if (params.startDate >= params.endDate) {
      return { success: false, errors: ['End must be after start'] };
    }
    // ... 150 lines of date range validation duplicated across entities
  }
}

class Phase {
  create(params) {
    if (params.startDate >= params.endDate) { // Duplicate!
      return { success: false, errors: ['End must be after start'] };
    }
  }
}
```

**After Value Objects:**
```typescript
// ‚úÖ Validation in one place
class DateRange {
  static create(start: Date, end: Date): DomainResult<DateRange> {
    if (start >= end) {
      return { success: false, errors: ['End must be after start'] };
    }
    return { success: true, data: new DateRange(start, end) };
  }
  
  overlaps(other: DateRange): boolean { /* ... */ }
  getDurationInDays(): number { /* ... */ }
}

// Entities use value objects
class Project {
  private _dateRange: DateRange;
  
  static create(params) {
    const rangeResult = DateRange.create(params.startDate, params.endDate);
    if (!rangeResult.success) return rangeResult;
    // ... validation done, use the value object
  }
}
```

### Our Value Objects

**Implemented (December 2025):**
```
src/domain/value-objects/
‚îú‚îÄ‚îÄ DateRange.ts       ‚Üí Date range validation, overlap detection, duration
‚îú‚îÄ‚îÄ EmailAddress.ts    ‚Üí Email validation and formatting
‚îú‚îÄ‚îÄ PhoneNumber.ts     ‚Üí Phone validation and formatting
‚îú‚îÄ‚îÄ Color.ts           ‚Üí Hex color validation and manipulation
‚îî‚îÄ‚îÄ index.ts           ‚Üí Barrel export
```

**Usage:**
- **DateRange**: Used by Project, Phase, Holiday entities (~150 lines duplication removed)
- **EmailAddress**: Used by Client entity (email validation)
- **PhoneNumber**: Used by Client entity (phone validation)
- **Color**: Used by Project, Phase, Label entities (color validation + HSL/RGB conversion)

**Integration Status:** Created but not yet integrated into entities (gradual adoption)

### Value Objects vs Entities

| Aspect | Value Object | Entity |
|--------|-------------|--------|
| **Identity** | Defined by value | Has unique ID |
| **Mutability** | Immutable | Can change over time |
| **Equality** | Two with same value are equal | Two with same ID are equal |
| **Lifecycle** | No lifecycle (just created/discarded) | Tracked lifecycle (create/update/delete) |
| **Examples** | DateRange, EmailAddress, Money | Project, Client, Phase |

**Key Rule:** If you can replace it with an identical copy and nobody would notice, it's a Value Object.

---

## Domain Services (December 2025 ‚Üí Merging January 2026)

### ‚ö†Ô∏è Migration Status

**Domain services are being MERGED into `domain/rules/`** as part of the three-layer simplification.

| Current Location | Target Location |
|------------------|-----------------|
| `domain/domain-services/PhaseRecurrenceService.ts` | `domain/rules/phases/PhaseRecurrence.ts` |
| `domain/domain-services/ProjectBudgetService.ts` | `domain/rules/projects/ProjectBudget.ts` |
| `domain/domain-services/PhaseDistributionService.ts` | `domain/rules/phases/PhaseDistribution.ts` |

**Why merge?**
- Same purity guarantees (no UI, no DB)
- Fewer folders to navigate
- One answer to "where does business logic go?"
- Calculations stay co-located with validation

### What Are Domain Services?

**Domain Services** contain pure domain logic that doesn't naturally fit within a single entity. They are:
- **Stateless** (no internal state)
- **Pure functions** (no side effects, no dependencies)
- **Domain-focused** (no persistence, no UI)
- **Reusable** (shared across entities and orchestrators)

### Current Domain Services (Being Migrated)

**Implemented (December 2025) ‚Üí Migrating to domain/rules/ (January 2026):**
```
‚ö†Ô∏è CURRENT (src/domain/domain-services/):
‚îú‚îÄ‚îÄ PhaseRecurrenceService.ts   ‚Üí Recurring phase patterns (~430 lines)
‚îú‚îÄ‚îÄ ProjectBudgetService.ts     ‚Üí Budget analysis (~400 lines)
‚îú‚îÄ‚îÄ PhaseDistributionService.ts ‚Üí Time distribution (~460 lines)
‚îî‚îÄ‚îÄ index.ts                    ‚Üí Barrel export

‚úÖ TARGET (src/domain/rules/):
‚îú‚îÄ‚îÄ phases/
‚îÇ   ‚îú‚îÄ‚îÄ PhaseRecurrence.ts      ‚Üê From PhaseRecurrenceService
‚îÇ   ‚îú‚îÄ‚îÄ PhaseDistribution.ts    ‚Üê From PhaseDistributionService
‚îÇ   ‚îî‚îÄ‚îÄ PhaseBudget.ts
‚îú‚îÄ‚îÄ projects/
‚îÇ   ‚îî‚îÄ‚îÄ ProjectBudget.ts        ‚Üê From ProjectBudgetService
‚îî‚îÄ‚îÄ sync/
    ‚îú‚îÄ‚îÄ DateSync.ts             ‚Üê Cross-cutting date logic
    ‚îî‚îÄ‚îÄ BudgetSync.ts           ‚Üê Cross-cutting budget logic
```

**1. PhaseRecurrenceService** ‚Üí `domain/rules/phases/PhaseRecurrence.ts`:
```typescript
// Validate recurring pattern
PhaseRecurrence.validateConfig(true, config, 8);

// Generate occurrence dates (inline rrule math)
PhaseRecurrence.generateOccurrences({
  config: { type: 'weekly', interval: 2, weeklyDayOfWeek: 1 },
  projectStartDate, projectEndDate
});

// Human description
PhaseRecurrence.getDescription(config);
// "Every 2 weeks on Monday"
```

**2. ProjectBudgetService** ‚Üí `domain/rules/projects/ProjectBudget.ts`:
```typescript
// Check budget status (inline budget math)
ProjectBudget.checkConstraint(phases, 100);
// { isValid: true, totalAllocated: 85, remaining: 15, ... }

// Comprehensive analysis
ProjectBudget.analyze(phases, projectBudget);
// { recommendations: [...], isOverBudget: false, ... }
```

**3. PhaseDistributionService** ‚Üí `domain/rules/phases/PhaseDistribution.ts`:
```typescript
// Allocation statistics (inline math)
PhaseDistribution.calculateAllocationDistribution(phases);
// { min, max, avg, median, standardDeviation }

// Spacing recommendations
PhaseDistribution.generateSpacingRecommendation(start, end, currentCount);
// { recommendedDates: [...], intervalDays: 7, reasoning: "..." }
```

### Key Principle: Math Inline

**Before (separate utilities):**
```typescript
import { DateMath } from '@/utils/math';
const days = DateMath.daysBetween(start, end);
```

**After (inline with business logic):**
```typescript
// In domain/rules/phases/PhaseDistribution.ts
const days = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
```

**Why?** Calculations belong with the business logic that uses them. Extracting to utilities creates indirection without value.

---

## Key Architectural Decisions

### 1. Three-Layer Documentation Model

**Domain Logic** (`/src/domain/Domain Logic.md`) defines WHAT exists (domain truth):
- "Projects have three time types: auto-estimated, planned, completed"
- "All time types coexist in the domain simultaneously"

**Rules Logic** (`/src/domain/Rules Logic.md`) defines HOW calculations work (domain rules):
- "Auto-estimate = (Remaining Hours) √∑ (Days without events)"
- "Events exclude days from auto-estimate distribution"

**Display Logic** (`/src/domain/Display Logic.md`) defines WHERE display constraints apply:
- "Timeline View shows only ONE time type per day (mutual exclusivity)"
- "Calendar View can show multiple time types (no overlap constraint)"

### 2. Domain Truth vs UI Constraints

**Example: Rule 9 (Daily Time Allocation)**

**Domain Truth** (Rules Logic):
- Auto-estimated, planned, and completed time all exist
- Calculations run regardless of display
- All time types are always available

**Display Constraint** (Display Logic):
- Timeline bars can't overlap visually
- Display only ONE type per day in Timeline View
- Same data shown differently in Calendar View

### 3. No Repository Layer

**Why:** Supabase already provides:
- Type-safe queries
- Row-level security
- Real-time subscriptions
- Query builder

Adding repositories would create:
- Wrapper methods that just delegate
- Extra abstraction with no value
- Development slowdown

**Pattern:**
```typescript
// ‚úÖ Direct Supabase (our approach)
const { data } = await supabase.from('projects').select('*');

// ‚ùå Repository wrapper (unnecessary)
const data = await projectRepository.findAll();
```

---

## Migration Path: Moving to Strict DDD

**When to Consider:**
- Team grows beyond 5-7 developers
- Domain logic leaking into orchestrators becomes painful
- Multiple clients need same backend (API reuse)
- Testing becomes difficult due to mixed concerns

### Phase 1 (Current) ‚Üí Phase 2 (Strict DDD)

**What Changes:**

### 1. Add Repository Layer (3-4 weeks)

**Current:**
```typescript
// Orchestrators call Supabase directly
await supabase.from('projects').insert(data);
```

**Strict DDD:**
```typescript
// Orchestrators call repositories
await projectRepository.create(data);

// repositories/ProjectRepository.ts
class ProjectRepository {
  async create(data: Project): Promise<Project> {
    return await supabase.from('projects').insert(data);
  }
}
```

**Effort:** 
- Create repository for each entity (9 files)
- Update all orchestrator calls
- Add repository tests

### 2. Extract Presentation Logic (2-3 weeks)

**Current:**
```typescript
// Orchestrators mix app + presentation
class ProjectOrchestrator {
  async createProject(data) {
    const dbData = this.transformForDatabase(data); // Presentation
    const project = await supabase.insert(dbData);
    return this.enrichForDisplay(project); // Presentation
  }
}
```

**Strict DDD:**
```typescript
// Application Services (pure app logic)
class ProjectApplicationService {
  async createProject(data: CreateProjectInput) {
    const validation = ProjectRules.validate(data);
    const project = await projectRepository.create(data);
    return project; // Pure entity
  }
}

// Presentation Adapters (UI prep)
class ProjectPresentationAdapter {
  static enrichForDisplay(project: Project) {
    return { ...project, displayColor: ... };
  }
}
```

**Effort:**
- Create application services layer (9 files)
- Create presentation adapters layer (new folder)
- Migrate all orchestrator logic
- Update component imports

### 3. Enforce Entity Usage (1-2 weeks)

**Current:**
```typescript
// Orchestrators work with plain data
const project = { id: '123', name: 'Test' };
```

**Strict DDD:**
```typescript
// Everything uses entity instances
const project = Project.create({ name: 'Test' });
if (!project.success) return project.errors;

const entity = project.data; // Always a Project instance
entity.isActiveOnDate(today); // Use entity methods
```

**Effort:**
- Update all orchestrators to use entities
- Update all unified services to accept entities
- Ensure entities used in components

### 4. Update Documentation (1 week)

**Effort:**
- Update `.architecture` with new layers
- Document repository patterns
- Update AI decision matrix
- Add migration notes

---

## Total Migration Estimate

**Time:** 8-12 weeks (depending on team size)

**Breakdown:**
- Week 1-4: Repository layer + tests
- Week 5-7: Extract presentation logic
- Week 8-9: Enforce entity usage everywhere
- Week 10-11: Update documentation
- Week 12: Buffer for issues

**Risk:** Medium (no breaking changes, gradual migration possible)

**Benefit:** Full code-level layer separation, easier testing, API reuse

---

## Future DDD Building Blocks (May Add Later)

These are standard DDD patterns we may adopt when needed:

### Domain Events (`domain/domain-events/`) - NOT YET IMPLEMENTED  
- **Purpose:** Things that happened in the domain
- **Example:** ProjectCreated, PhaseCompleted events
- **Status:** Not needed yet
- **Trigger:** When need to decouple side effects (notifications, integrations)

### Aggregates (`domain/aggregates/`) - NOT YET IMPLEMENTED
- **Purpose:** Cluster of entities treated as a single unit
- **Example:** Project + Phases as ProjectAggregate
- **Status:** Entities work independently
- **Trigger:** When complex transaction boundaries needed

**Note:** These can be added incrementally without major refactoring.

---

## Decision: Three-Layer Simplification (January 2026)

**Previous State (December 2025):**
- Business logic in 5+ locations (rules, domain-services, unified, calculations, orchestrators)
- "Where does this go?" had multiple correct answers
- Good purity, but too many folders

**Current Migration (January 2026):**
- Simplifying to THREE clear layers
- See `/docs/operations/ARCHITECTURE_REBUILD_PLAN.md` for detailed plan

**Target Architecture:**
```
Layer 1: domain/rules/           ‚Üê ALL business logic (validation + calculations inline)
Layer 2: services/orchestrators/ ‚Üê Workflows only (NO logic)
Layer 3: services/data/          ‚Üê Transformation + aggregation only
```

**Key Changes:**
| What | From | To |
|------|------|-----|
| Domain Services | `domain/domain-services/` | Merge ‚Üí `domain/rules/` |
| Calculations | `services/calculations/` | Merge ‚Üí `domain/rules/` (inline) |
| Unified Services | `services/unified/` | Split ‚Üí `domain/rules/` + `services/data/` |
| Math Utilities | Separate files | Inline with business logic |

**Progress (January 2026):**
- ‚úÖ Architecture plan created
- ‚úÖ Audit completed (documented bypass of domain rules)
- ‚úÖ Three-layer structure designed
- ‚è≥ Phase 1: Merge domain-services ‚Üí rules (In Progress)
- ‚è≥ Phase 2: Create services/data/ layer
- ‚è≥ Phase 3-6: Migrate orchestrators, UI, cleanup

**Review Triggers for Strict DDD:**
- Team grows beyond 7 developers
- Need to build separate API/mobile client
- Testing becomes difficult with current structure

---

## Quick Reference

**Target Architecture (Three-Layer Hybrid DDD):**
```
Components ‚Üí Orchestrators (coordination) ‚Üí Domain Rules (ALL business logic)
                      ‚Üì
               Data Services (transformation only)
                      ‚Üì
               Supabase (direct calls)

Domain Layer (Pure):
  domain/rules/
  ‚îú‚îÄ‚îÄ phases/ (PhaseValidation, PhaseRecurrence, PhaseDistribution, PhaseBudget)
  ‚îú‚îÄ‚îÄ projects/ (ProjectValidation, ProjectBudget, ProjectPhaseManager)
  ‚îú‚îÄ‚îÄ sync/ (DateSync, BudgetSync) ‚Üê Cross-cutting
  ‚îú‚îÄ‚îÄ calendar-events/
  ‚îî‚îÄ‚îÄ ...
       ‚Üë
  domain/value-objects/ (DateRange, EmailAddress, etc.)
       ‚Üë
  domain/entities/ (Project, Phase, Client)
```

**Current Architecture (Being Migrated):**
```
Components ‚Üí Orchestrators ‚Üí Entities + Rules + Domain Services + Unified + Supabase

‚ö†Ô∏è Too many paths for business logic:
  - domain/rules/
  - domain/domain-services/  ‚Üê Merging into rules
  - services/unified/        ‚Üê Splitting
  - services/calculations/   ‚Üê Merging into rules
```

**Documentation (Never Changes):**
```
Domain Logic.md ‚Üí Rules Logic.md ‚Üí Display Logic.md
(Pure domain truth, regardless of code approach)
```

---

**Bottom Line:** We simplified from 5+ layers to 3 clear layers. Same purity, fewer folders, one answer to "where does this go?"
