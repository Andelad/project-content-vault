# Test Component Development Guide

**AI Development Guide for creating isolated test environments for experimental components**

## Overview

This guide provides a systematic approach for creating isolated test environments to experiment with new component implementations without affecting production code. The strategy uses **service overrides** and **component isolation** to enable safe experimentation.

## Core Principles

1. **Zero Production Impact** - Never modify existing production files
2. **Selective Override** - Only create override files when business logic differs
3. **Strategic Reuse** - Import and reuse existing services/components where possible
4. **Clean Migration Path** - Structure allows easy promotion to production
5. **Easy Cleanup** - Complete test environment can be deleted safely

## File Structure Strategy

### Base Test Directory Structure
```
src/
‚îú‚îÄ‚îÄ components/         # Production components
‚îú‚îÄ‚îÄ services/          # Production services
‚îú‚îÄ‚îÄ hooks/             # Production hooks
‚îú‚îÄ‚îÄ test/              # üéØ EXPERIMENTAL AREA
‚îÇ   ‚îî‚îÄ‚îÄ {experimentName}/
‚îÇ       ‚îú‚îÄ‚îÄ README.md                    # Document the experiment
‚îÇ       ‚îú‚îÄ‚îÄ views/                       # Only create if needed
‚îÇ       ‚îú‚îÄ‚îÄ components/                  # Only create if needed
‚îÇ       ‚îú‚îÄ‚îÄ services/                    # Only create for overrides
‚îÇ       ‚îú‚îÄ‚îÄ hooks/                       # Only create if needed
‚îÇ       ‚îú‚îÄ‚îÄ types/                       # Only create if needed
‚îÇ       ‚îî‚îÄ‚îÄ utils/                       # Only create if needed
‚îî‚îÄ‚îÄ ...
```

### Progressive File Creation
**Start minimal** - Only create directories and files as they become necessary:

1. **Start with**: `README.md` to document experiment goals
2. **Add views** when you need a new main component
3. **Add services** only when overriding existing business logic
4. **Add components** only when creating new UI components
5. **Add hooks/types/utils** as complexity grows

## Step-by-Step Implementation Guide

### Step 1: Initialize Test Environment

1. **Create experiment directory:**
   ```
   src/test/{experimentName}/
   ```

2. **Create README.md** to document the experiment:
   ```markdown
   # {ExperimentName} Test Implementation
   
   ## Goals
   - [List experiment objectives]
   
   ## Key Differences from Production
   - [List business logic changes]
   
   ## Migration Notes
   - [Notes for potential promotion to production]
   ```

### Step 2: Implement Main View Component

**Only create when needed**: If experimenting with a completely new view.

```typescript
// test/{experimentName}/views/{ExperimentName}View.tsx
import React from 'react';
// Import existing components where possible
import { ViewportConfig } from '@/services/calculations/timelineCalculations';
import TimelineDateHeaders from '@/components/timeline/TimelineDateHeaders';

export function {ExperimentName}View() {
  // Implementation
}
```

### Step 3: Add Routing (Minimal Changes)

**Update routing files only when ready to test the view:**

```typescript
// In MainAppLayout.tsx - ADD ONLY, don't modify existing
const {ExperimentName}View = React.lazy(() => 
  import('@/test/{experimentName}/views/{ExperimentName}View')
    .then(module => ({ default: module.{ExperimentName}View }))
);

// In switch statement - ADD new case only
case '{experimentName}':
  return <{ExperimentName}View />;
```

```typescript
// In TimelineContext.tsx - ADD new view option
// setCurrentView('{experimentName}') when testing
```

### Step 4: Service Override Strategy

**Critical Rule**: Only create service override files when business logic differs from production.

#### Pattern A: Re-export with Extensions
```typescript
// test/{experimentName}/services/{experimentName}Calculations.ts

// Re-export everything from production
export * from '@/services/calculations/timelineCalculations';

// Override only what's different
export function calculateAutoRowPosition(
  project: Project,
  autoRowIndex: number,
  viewport: ViewportConfig
): TimelinePosition {
  // New auto-row logic here
  const basePosition = calculateProjectPosition(
    project.startDate,
    project.endDate,
    viewport
  );
  
  // Auto-calculate row positioning
  const rowHeight = 60;
  const top = autoRowIndex * rowHeight;
  
  return {
    ...basePosition,
    top,
    height: rowHeight
  };
}
```

#### Pattern B: Business Logic Overrides
```typescript
// test/{experimentName}/services/{experimentName}BusinessLogic.ts

export interface AutoGeneratedRow {
  id: string;
  projectIds: string[];
  category: string;
  autoGenerated: true;
}

export function generateRowsFromProjects(
  projects: Project[]
): AutoGeneratedRow[] {
  // Group projects by category for auto-row generation
  const groupedProjects = groupBy(projects, 'category');
  
  return Object.entries(groupedProjects).map(([category, categoryProjects]) => ({
    id: `auto-row-${category}`,
    projectIds: categoryProjects.map(p => p.id),
    category,
    autoGenerated: true
  }));
}
```

### Step 5: Component Creation Strategy

**Only create components when you need different UI behavior:**

```typescript
// test/{experimentName}/components/{ExperimentName}Grid.tsx
import React from 'react';
// Reuse existing components where possible
import TimelineBar from '@/components/timeline/TimelineBar';
import { calculateAutoRowPosition } from '@/test/{experimentName}/services/{experimentName}Calculations';

export function {ExperimentName}Grid() {
  // New grid logic with auto-rows
}
```

### Step 6: Import Strategy Guidelines

**Reuse First, Override Second:**

```typescript
// ‚úÖ GOOD: Reuse existing production components
import TimelineBar from '@/components/timeline/TimelineBar';
import { useProjectContext } from '@/contexts/ProjectContext';
import { calculateProjectPosition } from '@/services/calculations/timelineCalculations';

// ‚úÖ GOOD: Import from test overrides only when needed
import { calculateAutoRowPosition } from '@/test/{experimentName}/services/{experimentName}Calculations';

// ‚ùå AVOID: Don't recreate what already works
// Don't create {ExperimentName}ProjectBar.tsx if TimelineBar works fine
```

## Service Override Patterns

### When to Create Service Overrides

Create override files only when:
- ‚úÖ Business logic differs (e.g., auto-generated vs manual rows)
- ‚úÖ Calculation methods need modification
- ‚úÖ Data structures are different

Don't create overrides when:
- ‚ùå UI styling is different (use CSS/props instead)
- ‚ùå Only presentation changes (modify components, not services)
- ‚ùå Configuration differences (use props/context instead)

### Override File Templates

#### Calculation Override Template
```typescript
// services/{experimentName}Calculations.ts
import { ViewportConfig, TimelinePosition } from '@/services/calculations/timelineCalculations';

// Re-export production functions
export * from '@/services/calculations/timelineCalculations';

// Add/override specific functions
export function calculate{NewFeature}Position(
  // parameters
): TimelinePosition {
  // New calculation logic
}
```

#### Business Logic Override Template
```typescript
// services/{experimentName}BusinessLogic.ts
export interface {ExperimentName}Config {
  // New configuration interface
}

export function {newBusinessLogic}Function(
  // parameters
): ResultType {
  // New business logic
}
```

## Testing and Validation

### Incremental Development Process

1. **Create minimal structure** (README + main view)
2. **Test routing integration** (ensure view loads)
3. **Add service overrides progressively** (test each change)
4. **Validate against production** (compare behavior)
5. **Document differences** (update README)

### Validation Checklist

- [ ] Experiment loads without errors
- [ ] Production timeline unaffected
- [ ] Service overrides work correctly
- [ ] All imports resolve properly
- [ ] No circular dependencies
- [ ] Clean console (no warnings/errors)

## Migration Strategy

### If Experiment Succeeds

**Option A: Direct Integration**
```typescript
// Copy override functions to production services
// src/services/calculations/timelineCalculations.ts
export function calculateAutoRowPosition(
  // Move from test override to production
) {
  // Tested logic from experiment
}
```

**Option B: Feature Flag Integration**
```typescript
// Add configuration-based logic to production
export function calculateRowPosition(
  project: Project,
  config: { mode: 'manual' | 'auto' }
): RowPosition {
  if (config.mode === 'auto') {
    return calculateAutoRowPosition(project);
  }
  return calculateManualRowPosition(project);
}
```

**Option C: Complete Replacement**
- Move test components to production locations
- Update all imports
- Remove old implementation

### If Experiment Fails

**Clean Removal:**
```bash
rm -rf src/test/{experimentName}
```

**Revert routing changes:**
- Remove routing case from `MainAppLayout.tsx`
- Remove view option from `TimelineContext.tsx`

## Best Practices

### Do's ‚úÖ
- Document experiment goals in README
- Start with minimal file structure
- Reuse existing components where possible
- Create overrides only when business logic differs
- Test incrementally
- Keep production code untouched

### Don'ts ‚ùå
- Don't modify existing production files
- Don't create unnecessary override files
- Don't duplicate working components
- Don't skip documentation
- Don't commit broken experiments
- Don't leave dead code in test directories

## Example: TimelineV2 Implementation

### Minimal Starting Structure
```
src/test/timelineV2/
‚îú‚îÄ‚îÄ README.md                                    # Document auto-row experiment
‚îî‚îÄ‚îÄ views/
    ‚îî‚îÄ‚îÄ TimelineV2View.tsx                      # Main view component
```

### Progressive Addition (as needed)
```
src/test/timelineV2/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ views/
‚îÇ   ‚îî‚îÄ‚îÄ TimelineV2View.tsx
‚îú‚îÄ‚îÄ services/                                   # Only when row logic differs
‚îÇ   ‚îú‚îÄ‚îÄ timelineV2Calculations.ts              # Auto-row calculations
‚îÇ   ‚îî‚îÄ‚îÄ timelineV2RowLogic.ts                  # Auto-row generation
‚îú‚îÄ‚îÄ components/                                 # Only for new UI components
‚îÇ   ‚îî‚îÄ‚îÄ TimelineV2RowManager.tsx               # Auto-row management
‚îî‚îÄ‚îÄ hooks/                                      # Only for new state logic
    ‚îî‚îÄ‚îÄ useAutoRowGeneration.ts                # Auto-row hooks
```

### Import Strategy Example
```typescript
// TimelineV2View.tsx
import React from 'react';

// Reuse existing production components
import TimelineBar from '@/components/timeline/TimelineBar';
import TimelineDateHeaders from '@/components/timeline/TimelineDateHeaders';
import { useProjectContext } from '@/contexts/ProjectContext';

// Import from production services (what works)
import { calculateProjectPosition, ViewportConfig } from '@/services/calculations/timelineCalculations';

// Import from test overrides (what's different)
import { calculateAutoRowPosition, generateRowsFromProjects } from '@/test/timelineV2/services/timelineV2Calculations';
```

## File Naming Conventions

- **Views**: `{ExperimentName}View.tsx`
- **Components**: `{ExperimentName}{ComponentType}.tsx`
- **Services**: `{experimentName}{ServiceType}.ts`
- **Hooks**: `use{ExperimentName}{HookType}.ts`
- **Types**: `{experimentName}Types.ts`
- **Utils**: `{experimentName}Utils.ts`

## Integration with Existing Architecture

### Context Reuse
```typescript
// Always reuse existing contexts
import { useProjectContext } from '@/contexts/ProjectContext';
import { useSettingsContext } from '@/contexts/SettingsContext';
import { useTimelineContext } from '@/contexts/TimelineContext';
```

### Service Integration
```typescript
// Extend existing services, don't replace
import { 
  calculateProjectPosition,  // Keep what works
  ViewportConfig            // Reuse types
} from '@/services/calculations/timelineCalculations';

// Add experiment-specific functions
export function calculateExperimentSpecificLogic() {
  // New logic here
}
```

### Component Hierarchy
```typescript
// Maintain component reuse hierarchy
{ExperimentName}View
‚îú‚îÄ‚îÄ TimelineDateHeaders         // Reuse existing
‚îú‚îÄ‚îÄ {ExperimentName}Grid        // New grid logic
‚îÇ   ‚îú‚îÄ‚îÄ TimelineBar            // Reuse existing project bars
‚îÇ   ‚îî‚îÄ‚îÄ {ExperimentName}RowManager  // New row management
‚îî‚îÄ‚îÄ TimelineColumnMarkers       // Reuse existing
```

---

**Remember**: The goal is safe experimentation with maximum reuse and minimal disruption. Only create what's necessary, when it's necessary.
