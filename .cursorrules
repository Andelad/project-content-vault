# ğŸš¨ AI Development Guide

## INSTRUCTION FOR AI COPILOT
This guide must be followed for ALL code changes in this project.

> **ğŸ¤– AI REMINDER**: For complex features involving multiple service layers, workflows, or architectural decisions, ALSO read `docs/architecture/Architecture Guide.md` to understand the complete services architecture, service layer responsibilities, and development workflow patterns.

---

## ğŸ”„ DEVELOPMENT WORKFLOW (VS Code â†” Lovable â†” Supabase)

### Development Environment Split

| Tool | Purpose | Access |
|------|---------|--------|
| **VS Code (Copilot/Cursor)** | TypeScript, React, business logic, services | Local files only |
| **Lovable** | Database migrations, Supabase schema changes | Supabase integration |
| **GitHub** | Sync point between VS Code and Lovable | Automatic sync |

### Workflow Pattern

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VS Code (Local Development)                                     â”‚
â”‚  â€¢ Write TypeScript/React code                                   â”‚
â”‚  â€¢ Create services, components, hooks                            â”‚
â”‚  â€¢ Update business logic                                         â”‚
â”‚  â€¢ Create INSTRUCTIONS_FOR_LOVABLE_*.md files for DB changes     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ git push
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GitHub (Sync Point)                                             â”‚
â”‚  â€¢ Automatic sync to Lovable                                     â”‚
â”‚  â€¢ Code review and history                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ auto-sync
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Lovable (Database Changes)                                      â”‚
â”‚  â€¢ Read INSTRUCTIONS_FOR_LOVABLE_*.md files                      â”‚
â”‚  â€¢ Execute database migrations                                   â”‚
â”‚  â€¢ Create/modify Supabase tables, RLS policies, indexes          â”‚
â”‚  â€¢ Has direct Supabase access                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### For AI Agents (VS Code/Copilot/Cursor)

**When you identify database changes needed:**
1. âŒ **DO NOT** attempt to run SQL migrations directly
2. âœ… **DO** create an `INSTRUCTIONS_FOR_LOVABLE_[FEATURE].md` file in the project root
3. âœ… **DO** include exact SQL migration scripts in the instructions
4. âœ… **DO** explain the purpose, expected outcomes, and verification steps
5. âœ… **DO** commit and push to GitHub for Lovable to pick up

**Instruction File Template:**
```markdown
# Instructions for Lovable: [Feature Name]

## Purpose
[Explain what this migration accomplishes]

## Prerequisites
[Any existing state or requirements]

## Migration SQL
\`\`\`sql
-- Your migration SQL here
\`\`\`

## Verification
[How to verify the migration worked]

## Rollback (if needed)
\`\`\`sql
-- Rollback SQL here
\`\`\`
```

### For Lovable

When you see `INSTRUCTIONS_FOR_LOVABLE_*.md` files:
1. Read the instructions carefully
2. Execute the database migrations via Supabase
3. Verify the changes using the provided verification steps
4. Report success/failure
5. The instruction file can be deleted or archived after completion

---

## BEFORE WRITING ANY CODE
```bash
# Check if similar functionality exists
grep -r "functionName" src/services/
# Look for existing unified services
ls src/services/unified/ | grep -i "relevant-domain"
```

## NEVER CREATE
âŒ `/helpers/` directories (ambiguous - use proper service layers instead)  
âŒ Business logic in `/utils/` (calculations, validations, domain logic)  
âŒ Calculations in components  
âŒ Duplicate types (use `/types/core.ts`)  
âŒ Manual date math  

## ALWAYS USE
âœ… Import from `@/services` only  
âœ… Types from `/types/core.ts`  
âœ… Dates from `dateCalculations.ts` (normalizeToMidnight, addDaysToDate, etc.)  
âœ… **ErrorHandlingService for all errors** - structured logging with context  
âœ… **Find existing unified services** - look for `Unified*Service` pattern  
âœ… Delegation pattern in unified services  
âœ… **Typography changes** - update BOTH `index.css` CSS variables AND `tailwind.config.ts` fontSize/fontWeight  
âœ… **Text colors** - ONLY use centralized CSS variables in `index.css` (never hardcode)  

## WHERE CODE GOES (Updated November 2025)

| Code Type | Location | Pattern | Example |
|-----------|----------|---------|---------|
| UI | `/components` | Call orchestrators or unified services | `<div>{UnifiedXService.getData()}</div>` |
| Complex Workflows | `/services/orchestrators/*Orchestrator` | CREATE/UPDATE/DELETE with validation | `ProjectOrchestrator.executeProjectCreationWorkflow()` |
| Calculations | `/services/unified/Unified*Service` | READ/TRANSFORM operations | `UnifiedProjectService.calculateDuration()` |
| Business Rules | `/domain/rules/*Rules` | Single source of truth | `ProjectRules.validateProjectDates()` |
| Date/Time Math | `/services/calculations/general/dateCalculations` | Pure calculations | `calculateDurationHours()`, `normalizeToMidnight()` |
| **Error Handling** | **`ErrorHandlingService`** | **Structured logging + toast** | `ErrorHandlingService.handle(error, context, { showToast: true })` |
| **Validation** | **Inline in orchestrators** | **Call domain rules directly** | `ProjectRules.validate()` (NO validator layer) |
| **Data Access** | **Inline in orchestrators OR hooks** | **Direct Supabase calls** | `supabase.from('projects').insert()` (NO repository layer) |
| **React Coordination** | **`/hooks/use*.ts`** | **State + service calls** | `useProjectDrag()` (manages state, calls services) |
| Generic Utils | `/utils` or `/lib` | Framework helpers | `cn()`, `formatCurrency()`, `debounce()` |

**Key Changes:**
- âŒ NO `/validators` folder - call domain rules directly
- âŒ NO `/repositories` folder - call Supabase directly (except timeTrackingRepository)
- âœ… Orchestrators handle validation + data access inline

## CRITICAL PATTERNS (Updated October 2025)

### ğŸ” Find Existing Services First
```bash
# Before creating ProjectService, check:
ls src/services/unified/ | grep -i project
ls src/services/orchestrators/ | grep -i project
# Use whatever exists: UnifiedProjectService, ProjectOrchestrator, etc.
```

### Components â†’ Orchestrators (for workflows)
```typescript
// âœ… RIGHT - Use orchestrator for CREATE/UPDATE/DELETE
import { ProjectOrchestrator } from '@/services';
const result = await ProjectOrchestrator.executeProjectCreationWorkflow(data, context);

// âŒ WRONG - Component calling database directly
const { data } = await supabase.from('projects').insert(projectData);
```

### Components â†’ Unified Services (for calculations)
```typescript
// âœ… RIGHT - Use unified service for calculations
import { UnifiedProjectService } from '@/services';
const duration = UnifiedProjectService.calculateDuration(project);

// âŒ WRONG - Manual calculations in components  
const duration = (end - start) / (1000 * 60 * 60);
```

### Orchestrators Call Domain Rules Directly (NO validator layer)
```typescript
// âœ… RIGHT - Orchestrator calls domain rules directly
export class ProjectOrchestrator {
  static async executeProjectCreationWorkflow(request, context) {
    // Call domain rules directly
    const validation = ProjectRules.validateProjectDates(request.startDate, request.endDate);
    if (!validation.isValid) return { success: false, errors: validation.errors };
    
    // Call Supabase directly (no repository)
    const { data, error } = await supabase.from('projects').insert(prepared);
  }
}

// âŒ WRONG - Creating validator wrapper
export class ProjectValidator {
  static validate(project) {
    return ProjectRules.validate(project); // Unnecessary wrapper!
  }
}
```

### Orchestrators Call Supabase Directly (NO repository layer)
```typescript
// âœ… RIGHT - Orchestrator calls Supabase directly
export class ProjectOrchestrator {
  static async executeProjectCreationWorkflow(request, context) {
    const prepared = this.transformToDatabase(request);
    const { data, error } = await supabase.from('projects').insert(prepared).select().single();
    return this.transformFromDatabase(data);
  }
  
  // Transformation helpers inline as private methods
  private static transformToDatabase(request) { /* ... */ }
  private static transformFromDatabase(data) { /* ... */ }
}

// âŒ WRONG - Creating repository wrapper
export class ProjectRepository {
  async create(project) {
    return supabase.from('projects').insert(project); // Unnecessary wrapper!
  }
}
```

### Unified Services MUST Delegate
```typescript
// âœ… RIGHT - Unified service delegates to domain layer
export class UnifiedProjectService {
  static calculateDuration(project: Project): number {
    return DateCalculations.calculateProjectDuration(project); // DELEGATE!
  }
}

// âŒ WRONG - Unified service implementing logic
export class UnifiedProjectService {
  static calculateDuration(project: Project): number {
    return (project.end - project.start) / (1000 * 60 * 60); // NO!
  }
}
```

### Types - ONLY extend core.ts
```typescript
// âœ… RIGHT
import { Project } from '@/types/core';
interface LocalProject extends Project { temp?: boolean; }

// âŒ WRONG
interface Project { id: string; } // NEVER redefine!
```

### Dates - ONLY use dateCalculations
```typescript
// âœ… RIGHT
import { calculateDurationHours, normalizeToMidnight, addDaysToDate } from '@/services';
const midnight = normalizeToMidnight(new Date());
const future = addDaysToDate(today, 7);

// âŒ WRONG  
date.setHours(0, 0, 0, 0); // NEVER manual date ops
const future = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000); // NEVER manual arithmetic
```

### Error Handling - ALWAYS use ErrorHandlingService
```typescript
// âœ… RIGHT - Structured error handling
import { ErrorHandlingService, ErrorSeverity } from '@/services';

try {
  await saveProject(project);
} catch (error) {
  ErrorHandlingService.handle(error, {
    source: 'ProjectModal',
    action: 'saveProject',
    metadata: { projectId: project.id }
  }, {
    showToast: true,
    severity: ErrorSeverity.ERROR,
    userMessage: 'Failed to save project. Please try again.'
  });
}

// âŒ WRONG - Inconsistent error handling
try {
  await saveProject(project);
} catch (error) {
  console.error('Error:', error); // NO!
  toast({ title: 'Error', description: 'Something went wrong' }); // NO!
}
```

## CHECKLIST (Updated November 2025)
- [ ] Did I check if this exists? (`grep -r`)
- [ ] Am I importing from `@/services`?
- [ ] Am I using core.ts types?
- [ ] Am I using dateCalculations for dates (NO manual .setHours or arithmetic)?
- [ ] Am I using ErrorHandlingService for all errors?
- [ ] Are unified services delegating to domain layers?
- [ ] Is business logic in services, not components?
- [ ] Am I calling domain rules directly (not creating validator wrappers)?
- [ ] Am I calling Supabase directly (not creating repository wrappers)?
- [ ] Are orchestrators handling workflows with inline validation?
- [ ] Are transformation helpers inline in orchestrators (private methods)?
- [ ] If creating a hook, does it only coordinate services (no business logic)?
- [ ] Are calculations in services, not hooks or components?

## ğŸ¯ DEVELOPMENT PHILOSOPHY
**"Find existing, extend existing, create new only when necessary"**
- Look for similar services first
- Use existing patterns and naming
- Maintain architectural principles over exact naming conventions

---

## ğŸ£ CUSTOM HOOKS - React Coordination Layer

### âœ… When to Create Custom Hooks
Create a custom hook when you need to:
- **Manage React state** with service coordination (useState, useReducer)
- **Handle complex DOM events** (drag handlers, scroll listeners, resize observers)
- **Coordinate multiple services** with React lifecycle (useEffect, useCallback)
- **Reuse React patterns** across multiple components
- **Clean up side effects** (event listeners, subscriptions, timers)

### âŒ Never Put in Hooks
- âŒ Business logic (belongs in `domain/rules`)
- âŒ Calculations (belongs in `services/calculations` or `services/unified`)
- âŒ Workflows (belongs in `services/orchestrators`)
- âŒ Database operations (belongs in orchestrators or data-fetching hooks)
- âŒ Pure functions (belongs in services)

### âœ… Correct Hook Pattern
```typescript
// âœ… GOOD: Hook coordinates services + manages React state
export function useProjectDrag(config: ProjectDragConfig) {
  const [isDragging, setIsDragging] = useState(false);
  const [dragState, setDragState] = useState<DragState | null>(null);
  
  const handleMouseDown = useCallback((e: React.MouseEvent, projectId: string, action: string) => {
    // Initialize using service
    const initialState = initializeDragState(project, action, e.clientX, e.clientY);
    setIsDragging(true);
    setDragState(initialState);
    
    const handleMouseMove = (e: MouseEvent) => {
      // Call service for calculations
      const result = TimelineDragCoordinatorService.coordinateDragOperation(
        dragState, e, timelineContext
      );
      // Update React state
      setDragState(result.newDragState);
    };
    
    // Setup DOM listeners
    document.addEventListener('mousemove', handleMouseMove);
    // ... cleanup
  }, [config]);
  
  return { isDragging, dragState, handleMouseDown };
}

// Component uses the hook
function TimelineView() {
  const { isDragging, dragState, handleMouseDown } = useProjectDrag({
    projects, updateProject, viewportStart, dates
  });
  // ... render
}
```

### âŒ Wrong Hook Pattern
```typescript
// âŒ BAD: Hook implements business logic
export function useProjectDrag(config) {
  const handleMouseDown = useCallback((e, projectId) => {
    // âŒ WRONG: Calculating in hook instead of using service
    const deltaX = e.clientX - startX;
    const daysDelta = Math.round(deltaX / 50);
    const newDate = new Date(startDate);
    newDate.setDate(startDate.getDate() + daysDelta);
    
    // âŒ WRONG: Business validation in hook
    if (newDate < minDate || newDate > maxDate) {
      return;
    }
    
    // âŒ WRONG: Database call in hook
    await supabase.from('projects').update({ startDate: newDate });
  }, []);
}
```

### ğŸ“‹ Hook Decision Tree
```
Do I need React state management?
  YES â†’ Do I need to coordinate services?
    YES â†’ Create custom hook âœ…
    NO â†’ Keep state in component âœ…
  NO â†’ Do I need calculations?
    YES â†’ Use existing service âœ…
    NO â†’ Is this a workflow?
      YES â†’ Use orchestrator âœ…
      NO â†’ Create utility function âœ…
```

### ğŸ”„ Hook Examples
```typescript
// âœ… Data fetching hook (thin Supabase wrapper)
function useProjects() {
  const [projects, setProjects] = useState([]);
  useEffect(() => {
    supabase.from('projects').select('*').then(setProjects);
  }, []);
  return projects;
}

// âœ… React coordination hook (manages state + calls services)
function useTimelineNavigation(config) {
  const [isAnimating, setIsAnimating] = useState(false);
  
  const handleNavigate = useCallback((direction) => {
    const target = TimelineViewportService.calculateNavigationTarget(config, direction);
    createSmoothDragAnimation(config, target, () => setIsAnimating(false));
  }, [config]);
  
  return { isAnimating, handleNavigate };
}

// âœ… DOM event coordination hook
function useTimelineAutoScroll(viewport) {
  const [autoScrollState, setAutoScrollState] = useState(null);
  
  const checkAutoScroll = useCallback((mouseX) => {
    const config = TimelineViewportService.calculateAutoScrollTrigger(mouseX);
    if (config.shouldScroll) {
      setAutoScrollState(config);
    }
  }, [viewport]);
  
  return { autoScrollState, checkAutoScroll };
}
```

---

## ğŸ¨ TYPOGRAPHY COLOR SYSTEM

### Single Source of Truth - CSS Variables in `index.css`

All text colors derive from centralized CSS variables. **Never hardcode text colors.**

```css
/* Typography Colors - Single Source of Truth */
--foreground: 0 0% 35%;           /* Primary text - dark grey */
--foreground-secondary: 0 0% 45%; /* Secondary text - medium grey */
--foreground-tertiary: 0 0% 60%;  /* Tertiary/muted text - light grey */
--foreground-disabled: 0 0% 70%;  /* Disabled/placeholder text */

/* Framework component colors reference these base values */
--card-foreground: 0 0% 35%;      /* Card text */
--popover-foreground: 0 0% 35%;   /* Dropdown/menu text */
--secondary-foreground: 0 0% 35%; /* Badge text */
--accent-foreground: 0 0% 35%;    /* Hover state text */
--muted-foreground: 0 0% 45%;     /* Secondary/muted text */
```

### âœ… Correct Usage
```typescript
// âœ… Use semantic Tailwind classes
<div className="text-foreground">Primary text</div>
<div className="text-muted-foreground">Secondary text</div>
<div className="text-gray-600">Secondary text (via override)</div>
<div className="text-primary">Brand color link</div>

// âœ… Use component variants that reference variables
<Badge variant="secondary">8 projects</Badge> // Uses --secondary-foreground
<Select>...</Select> // Uses --popover-foreground
<Button variant="ghost">...</Button> // Uses --accent-foreground on hover
```

### âŒ Never Do This
```typescript
// âŒ NEVER hardcode text colors
<div className="text-[#595956]">Text</div>
<div className="text-[#02c0b7]">Text</div>
<div style={{ color: '#595956' }}>Text</div>

// âŒ NEVER hardcode in CSS
.my-class {
  color: #595956; /* NO! */
}
```

### ğŸ”„ To Change App-Wide Text Color
1. Update `--foreground` in `src/index.css`
2. All derived variables and overrides automatically update
3. No code changes needed anywhere else

### ğŸ“‹ Color Variable Reference
| CSS Variable | Lightness | Usage | Tailwind Class |
|--------------|-----------|-------|----------------|
| `--foreground` | 35% | Primary text | `text-foreground`, `text-gray-900`, `text-gray-800` |
| `--foreground-secondary` | 45% | Secondary text | `text-muted-foreground`, `text-gray-600` |
| `--foreground-tertiary` | 60% | Tertiary text | `text-gray-500` |
| `--foreground-disabled` | 70% | Disabled text | Custom usage |
| `--primary` | (brand color) | Links, CTA buttons | `text-primary` |

### ğŸ¯ Hook Naming Convention
- âœ… `useProjectDrag` - Manages project drag state + coordinates DragCoordinator service
- âœ… `useHolidayDrag` - Manages holiday drag state + coordinates DragCoordinator service
- âœ… `useTimelineNavigation` - Manages navigation state + coordinates ViewportService
- âœ… `useTimelineAutoScroll` - Manages auto-scroll state + coordinates ViewportService
- âœ… `useProjects` - Fetches project data (thin Supabase wrapper)

### ğŸš¨ Services Don't Change
**Important**: Creating hooks does NOT require changing existing services!
- Services remain pure and stateless
- Services continue to do calculations and coordination
- Hooks just wrap React-specific concerns (state, lifecycle, DOM events)
- Same service functions are called, just from hooks instead of components
