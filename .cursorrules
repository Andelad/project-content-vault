# ðŸš¨ AI Development Guide

> **Note:** This file is named `.cursorrules` for compatibility with AI development tools that auto-detect it. It applies to ALL AI assistants (Cursor, Copilot, Claude, etc.), not just Cursor IDE.

> **Philosophy:** "Find existing, extend existing, create new only when necessary"

---

## ï¿½ ARCHITECTURE MIGRATION IN PROGRESS

**Current State:** Migrating to simplified three-layer architecture  
**Plan:** See `/docs/operations/ARCHITECTURE_REBUILD_PLAN.md`  
**Target:** THREE layers only - `domain/rules/`, `services/orchestrators/`, `services/data/`

**During Migration:**
- New business logic â†’ `domain/rules/` (organized by concern: phases/, projects/, sync/)
- New orchestrator code â†’ `services/orchestrators/` (coordination only)
- New data transformation â†’ `services/data/mappers/` or `services/data/aggregators/`
- Keep math inline with business logic (no separate MathUtils)

---

## ï¿½ðŸ“š DOCUMENTATION GUIDE

**Core Documents:**
- **`.ddd`** (root) - Hybrid DDD philosophy & architecture evolution
- **`.architecture`** (root) - WHERE code goes, structural patterns
- **`Domain Logic.md`** (`/src/domain/`) - WHAT entities are (concepts)
- **`Rules Logic.md`** (`/src/domain/`) - HOW calculations work (formulas)
- **`Display Logic.md`** (`/src/domain/`) - Display constraints & view rules
- **`README.md`** (`/src/components/`) - Component organization

**Quick Navigation:**
- Domain concepts â†’ `/src/domain/Domain Logic.md`
- Calculations/formulas â†’ `/src/domain/Rules Logic.md`
- Display constraints â†’ `/src/domain/Display Logic.md`
- Code structure â†’ `/.architecture`
- Hybrid DDD philosophy â†’ `/.ddd`
- Component files â†’ `/src/components/README.md`

---

## 1. QUICK REFERENCE

### Never Create
- âŒ `/helpers/` directories
- âŒ Business logic in `/utils/` or components
- âŒ Calculations in components
- âŒ Duplicate types (use `/types/core.ts`)
- âŒ Manual date math (use `dateCalculations.ts` for generic, inline for business-specific)
- âŒ Validator wrapper files (call domain rules directly)
- âŒ Repository wrapper files (call Supabase directly, except `timeTrackingRepository`)
- âŒ Domain/business logic in orchestrators (put in `domain/rules/`)
- âŒ Separate MathUtils files (keep math inline with business logic)
- âŒ New unified services (use `domain/rules/` or `services/data/` instead)

### Always Use
- âœ… Import from `@/services` only
- âœ… Types from `/types/core.ts`
- âœ… Domain rules from `/domain/rules/` for ALL business logic (validation + calculations)
- âœ… Domain entities from `/domain/entities/` when available
- âœ… `dateCalculations.ts` for generic date operations
- âœ… `ErrorHandlingService` for all errors
- âœ… Find existing domain rules first, then check orchestrators
- âœ… Keep calculations co-located with business logic that uses them

### Before Writing Code
```bash
grep -r "functionName" src/domain/rules/
grep -r "functionName" src/services/
```

---

## 2. CODE ORGANIZATION

**Architecture: Hybrid DDD - Three Layers** (see `.ddd` for philosophy)

| Code Type | Location | Purity | Example |
|-----------|----------|--------|---------|
| **Domain Rules** | `/domain/rules/*` | 100% pure (no UI/DB) | Validation + calculations (inline) |
| **Domain Entities** | `/domain/entities/*` | 100% pure (no UI/DB) | Rich objects with business methods |
| **Value Objects** | `/domain/value-objects/*` | 100% pure | DateRange, EmailAddress |
| **Orchestrators** | `/services/orchestrators/*Orchestrator` | Mixed (by design) | Workflows: validation + DB + UI prep |
| **Data Mappers** | `/services/data/mappers/*` | Pure transformation | DBâ†”UI field translation |
| **Data Aggregators** | `/services/data/aggregators/*` | Queries only | Multi-table queries + rollups |
| **UI Components** | `/components` | UI only | Call services, no logic |
| Date Math | `/services/calculations/general/dateCalculations` | Pure math | `normalizeToMidnight()` |
| Error Handling | `ErrorHandlingService` | Infrastructure | Structured logging |
| React State | `/hooks/use*.ts` | Coordination | State + service calls |
| Generic Utils | `/utils` or `/lib` | Pure helpers | `cn()`, `formatCurrency()` |

**âš ï¸ Legacy (Being Migrated):**
| Code Type | Location | Status |
|-----------|----------|--------|
| Domain Services | `/domain/domain-services/*` | â†’ Merging into `domain/rules/` |
| Unified Services | `/services/unified/*` | â†’ Splitting into `domain/rules/` + `services/data/` |
| Calculations | `/services/calculations/*` | â†’ Merging into `domain/rules/` |

**Orchestrator Scope (Hybrid DDD - Mixed by Design):**
- âœ… Call domain rules (`PhaseValidation.validate()`, `DateSync.synchronize()`)
- âœ… Call Supabase directly (no repository layer)
- âœ… Use data mappers for DB transformation
- âœ… Enrich data for UI display
- âœ… Coordinate workflows & side effects
- âŒ NEVER implement business rules (use `domain/rules/`)
- âŒ NEVER implement calculations (put in `domain/rules/` inline)
- âŒ NEVER create new unified services (use `domain/rules/` or `services/data/`)

---

## 3. PATTERNS

### Orchestrators (workflows)
```typescript
// âœ… Orchestrators coordinate & mix concerns (by design)
export class ProjectOrchestrator {
  static async executeProjectCreationWorkflow(request, context) {
    // âœ… Call domain rules (pure validation + calculations)
    const validation = ProjectValidation.validateProjectDates(request.startDate, request.endDate);
    if (!validation.isValid) return { success: false, errors: validation.errors };
    
    // âœ… Transform for DB (allowed)
    const prepared = this.transformForDatabase(request);
    
    // âœ… Direct Supabase (no repository layer)
    const { data, error } = await supabase.from('projects').insert(prepared).select().single();
    
    // âœ… Enrich for UI (allowed)
    return this.enrichForDisplay(data);
  }
  
  // âŒ FORBIDDEN - business logic belongs in domain/rules/
  // private calculateRemainingHours() { ... }
}
```

### Domain Rules (ALL business logic goes here)
```typescript
// âœ… Pure domain logic with calculations INLINE (no DB, no UI, no side effects)
// Located in domain/rules/{concern}/
export class PhaseRecurrence {
  static generateOccurrences(config: RecurringConfig, range: DateRange): Date[] {
    // Pure RRule-based logic, 100% testable
    // Calculations inline - no separate MathUtils
  }
  
  static validateRecurringConfig(config: RecurringConfig): ValidationResult {
    // Pure validation logic
  }
}

// âœ… Cross-cutting concerns in domain/rules/sync/
export class DateSync {
  static synchronizeProjectWithPhases(project: Project, phases: Phase[]): SyncResult {
    // Inline date calculations - no external math utilities
    const earliestStart = phases.reduce((earliest, phase) => {
      const start = new Date(phase.startDate);
      return !earliest || start < earliest ? start : earliest;
    }, null as Date | null);
    
    return { updatedProject: { ...project, startDate: earliestStart } };
  }
}
```

### Data Services (transformation only - NO business logic)
```typescript
// âœ… Pure data transformation (DBâ†”UI)
// Located in services/data/mappers/
export const PhaseMapper = {
  fromDatabase(row: DatabaseMilestone): PhaseDTO {
    return {
      id: row.id,
      endDate: new Date(row.due_date), // Field translation
    };
  },
  toDatabase(phase: PhaseDTO): Partial<DatabaseMilestone> {
    return {
      due_date: phase.endDate.toISOString(), // Reverse translation
    };
  }
};

// âœ… Multi-table queries (NO business logic)
// Located in services/data/aggregators/
export class PhaseAggregator {
  static async getPhasesWithTimeEntries(projectId: string) {
    // Pure data aggregation - no business rules
  }
}
```

### âš ï¸ Legacy Patterns (Being Migrated)
```typescript
// âš ï¸ LEGACY: domain-services/ â†’ merging into domain/rules/
export class PhaseRecurrenceService { ... } // â†’ domain/rules/phases/PhaseRecurrence.ts

// âš ï¸ LEGACY: unified/ â†’ splitting into domain/rules/ + services/data/
export class UnifiedProjectService { ... } // Business logic â†’ domain/rules/, data â†’ services/data/
```

### Dates
```typescript
// âœ… Use dateCalculations for generic operations
import { normalizeToMidnight, addDaysToDate } from '@/services';

// âœ… Inline simple date math in domain rules when business-specific
const daysDiff = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));

// âŒ Never manual date math in components or orchestrators
date.setHours(0, 0, 0, 0);
```

### Error Handling
```typescript
// âœ… Use ErrorHandlingService
ErrorHandlingService.handle(error, {
  source: 'ProjectModal',
  action: 'saveProject',
  metadata: { projectId: project.id }
}, { showToast: true });

// âŒ Never
console.error('Error:', error);
```

### Types
```typescript
// âœ… Extend core.ts
import { Project } from '@/types/core';
interface LocalProject extends Project { temp?: boolean; }

// âŒ Never redefine
interface Project { id: string; }
```

---

## 5. BUSINESS LOGIC CHANGES

When modifying business rules:

1. **Update `/src/domain/Domain Logic.md`** (entity definitions, concepts)
2. **Update `/src/domain/Rules Logic.md`** (detailed rules, calculations)
3. **Update `/src/domain/Display Logic.md`** (if display rules changed)
4. **Update `src/domain/rules/*.ts`** (with `@see` references)
5. **Update orchestrators** (workflows using the rule)
6. **Update tests**
7. **Commit with `logic:` prefix**

### What Requires Doc Updates
âœ… Validation rules, calculations, entities, relationships, UI display constraints

### What Doesn't
âŒ Bug fixes, refactoring, tests, performance optimizations

---

## 6. DOCUMENTATION

| Folder | Purpose | Action |
|--------|---------|--------|
| `/src/domain/` | Domain docs (3 files) | UPDATE existing only |
| `/docs/features/[name]/` | Feature docs | Permanent |
| `/docs/operations/` | Testing, deployment | Permanent |
| `/docs/sessions/` | **TEMPORARY** | AI working docs |

### AI Rules
1. âŒ Don't create docs in `/docs/` root or `/docs/features/`
2. âœ… Create temporary docs in `/docs/sessions/`
3. âœ… Update existing domain docs when logic changes
4. âœ… Remind user to delete `/docs/sessions/` files when done

---

## 7. HOOKS

### When to Create
- Managing React state with service coordination
- Handling DOM events (drag, scroll, resize)
- Coordinating services with React lifecycle
- Cleaning up side effects

### Never Put in Hooks
- âŒ Business logic â†’ `domain/rules`
- âŒ Calculations â†’ `services/unified`
- âŒ Workflows â†’ `services/orchestrators`
- âŒ Database operations â†’ orchestrators

> **Note:** Creating hooks does NOT require changing existing services. Services remain pure and stateless.

### Pattern
```typescript
// âœ… Hook coordinates services + manages state
export function useProjectDrag(config) {
  const [isDragging, setIsDragging] = useState(false);
  
  const handleMouseDown = useCallback((e, projectId) => {
    const result = TimelineDragCoordinatorService.coordinateDragOperation(dragState, e);
    setDragState(result.newDragState);
  }, [config]);
  
  return { isDragging, handleMouseDown };
}
```

---

## 9. CHECKLIST

Before committing:
- [ ] Checked for existing similar code? (`grep -r`)
- [ ] Importing from `@/services`?
- [ ] Using `core.ts` types?
- [ ] Using `dateCalculations` for dates?
- [ ] Using `ErrorHandlingService` for errors?
- [ ] Pure domain logic in `domain/domain-services/`, not unified/?
- [ ] Domain rules in `domain/rules/`, not orchestrators?
- [ ] Orchestrators coordinate only (no business logic)?
- [ ] Business logic in domain layer, not components?
- [ ] If domain logic changed: updated Domain Logic.md + Rules Logic.md?
- [ ] If UI constraint changed: updated Display Logic.md?
- [ ] Commit message has correct prefix?
