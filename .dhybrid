# Architecture Philosophy: Hybrid DDD

**Last Updated:** December 30, 2025  
**Current Approach:** Hybrid Domain-Driven Design (DDD)  
**Future Migration:** Strict DDD (if needed)

---

## Our Current Philosophy: Hybrid DDD

### What We Do

**Pure Documentation, Pragmatic Code**

We maintain **strict separation in documentation** while allowing **pragmatic mixing in code**:

```
üìö Documentation (Co-located with Code):
‚îú‚îÄ‚îÄ /.architecture              ‚Üí Overall architecture philosophy
‚îú‚îÄ‚îÄ /.dhybrid                   ‚Üí This file - Hybrid DDD evolution
‚îú‚îÄ‚îÄ /src/domain/
‚îÇ   ‚îú‚îÄ‚îÄ Domain Logic.md         ‚Üí Domain concepts (100% UI-agnostic)
‚îÇ   ‚îú‚îÄ‚îÄ Rules Logic.md          ‚Üí Domain rules & calculations (UI-agnostic)
‚îÇ   ‚îî‚îÄ‚îÄ Display Logic.md        ‚Üí Display-specific business rules
‚îî‚îÄ‚îÄ /src/components/
    ‚îî‚îÄ‚îÄ README.md               ‚Üí Component organization

üíª Code (Pragmatically Mixed):
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ entities/        ‚Üí Rich domain models ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ rules/           ‚Üí Pure domain logic ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ value-objects/   ‚Üí Immutable domain primitives ‚úÖ (Dec 2025)
‚îÇ   ‚îî‚îÄ‚îÄ domain-services/ ‚Üí Pure domain algorithms ‚úÖ (Dec 2025)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ orchestrators/ ‚Üí MIXED: App logic + UI prep + DB access
‚îÇ   ‚îú‚îÄ‚îÄ unified/       ‚Üí Business calculations ‚úÖ
‚îÇ   ‚îú‚îÄ‚îÄ calculations/  ‚Üí Pure math utilities ‚úÖ
‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/ ‚Üí Cross-cutting concerns ‚úÖ
‚îî‚îÄ‚îÄ components/         ‚Üí UI display ‚úÖ
```

**Key Principle:** Documentation lives near the code it describes.
- All domain documentation together in `/src/domain/`
- Component organization in `/src/components/`
- Architecture at project root (alongside `.cursorrules`)

### Where We Stay Pure

**Domain Layer** (`domain/`) - Never compromise:

1. **Entities** (`domain/entities/`) - Things with identity:
   - ‚úÖ Encapsulate state + behavior
   - ‚úÖ Validate on construction
   - ‚úÖ Self-contained business logic
   - ‚ùå NO UI concerns

2. **Value Objects** (`domain/value-objects/`) - Primitive concepts (NEW):
   - ‚úÖ Immutable by design
   - ‚úÖ Self-validating
   - ‚úÖ Defined by value, not identity
   - ‚úÖ Examples: DateRange, EmailAddress, PhoneNumber, Color
   - ‚ùå NO side effects

3. **Rules** (`domain/rules/`) - Complex validation logic:
   - ‚úÖ Pure business rules
   - ‚úÖ Calculations entities delegate to
   - ‚ùå NO UI references ("timeline", "calendar", "view")
   - ‚ùå NO presentation logic

4. **Domain Services** (`domain/domain-services/`) - Pure algorithms (NEW):
   - ‚úÖ Domain logic that doesn't fit in a single entity
   - ‚úÖ Pure functions (no dependencies)
   - ‚úÖ Examples: PhaseRecurrenceService, ProjectBudgetService
   - ‚ùå NO persistence, NO UI concerns

### Where We Mix (Intentionally)

**Orchestrators** (`services/orchestrators/`) - Pragmatic glue layer:
- ‚úÖ Application workflows (CREATE/UPDATE/DELETE)
- ‚úÖ Call domain validation (ProjectRules.validate())
- ‚úÖ Direct database access (supabase.from()... - NO repository layer)
- ‚úÖ Transform for database (mapping concerns)
- ‚úÖ Enrich for UI display (presentation prep)
- ‚úÖ Coordinate side effects (notifications, updates)

**Example:**
```typescript
async createProject(data: CreateProjectInput) {
  // ‚úÖ Call domain validation
  const validation = ProjectRules.validateCreate(data);
  
  // ‚úÖ Transform for DB (presentation - allowed)
  const dbData = this.transformForDatabase(data);
  
  // ‚úÖ Direct DB access (no repository layer)
  const project = await supabase.from('projects').insert(dbData);
  
  // ‚úÖ Enrich for UI (presentation - allowed)
  return this.enrichForDisplay(project);
}
```

### Why Hybrid?

**Velocity vs Purity Trade-off:**

| Aspect | Strict DDD | Hybrid DDD (Our Choice) |
|--------|-----------|-------------------------|
| **Layer Separation** | 100% code separation | Pure domain, mixed orchestrators |
| **Repository Layer** | Required abstraction | Direct Supabase calls |
| **Entity Usage** | Everywhere | Domain layer only |
| **Development Speed** | Slower (more abstraction) | Faster (pragmatic) |
| **Maintenance Clarity** | Code self-documents | Documentation self-documents |
| **Migration Effort** | 8-12 weeks | Already done ‚úÖ |

**Our Bet:** Clear documentation provides architectural clarity faster than full code separation.

---

## Value Objects (Added December 2025)

### What Are Value Objects?

**Value Objects** represent primitive domain concepts that:
- Are **immutable** (cannot change after creation)
- Are defined by their **value**, not identity (two DateRanges with same dates are equal)
- Are **self-validating** (cannot exist in invalid state)
- Have **no side effects** (pure logic only)

### Why Value Objects?

**Before Value Objects:**
```typescript
// ‚ùå Duplicate validation everywhere
class Project {
  create(params) {
    if (params.startDate >= params.endDate) {
      return { success: false, errors: ['End must be after start'] };
    }
    // ... 150 lines of date range validation duplicated across entities
  }
}

class Phase {
  create(params) {
    if (params.startDate >= params.endDate) { // Duplicate!
      return { success: false, errors: ['End must be after start'] };
    }
  }
}
```

**After Value Objects:**
```typescript
// ‚úÖ Validation in one place
class DateRange {
  static create(start: Date, end: Date): DomainResult<DateRange> {
    if (start >= end) {
      return { success: false, errors: ['End must be after start'] };
    }
    return { success: true, data: new DateRange(start, end) };
  }
  
  overlaps(other: DateRange): boolean { /* ... */ }
  getDurationInDays(): number { /* ... */ }
}

// Entities use value objects
class Project {
  private _dateRange: DateRange;
  
  static create(params) {
    const rangeResult = DateRange.create(params.startDate, params.endDate);
    if (!rangeResult.success) return rangeResult;
    // ... validation done, use the value object
  }
}
```

### Our Value Objects

**Implemented (December 2025):**
```
src/domain/value-objects/
‚îú‚îÄ‚îÄ DateRange.ts       ‚Üí Date range validation, overlap detection, duration
‚îú‚îÄ‚îÄ EmailAddress.ts    ‚Üí Email validation and formatting
‚îú‚îÄ‚îÄ PhoneNumber.ts     ‚Üí Phone validation and formatting
‚îú‚îÄ‚îÄ Color.ts           ‚Üí Hex color validation and manipulation
‚îî‚îÄ‚îÄ index.ts           ‚Üí Barrel export
```

**Usage:**
- **DateRange**: Used by Project, Phase, Holiday entities (~150 lines duplication removed)
- **EmailAddress**: Used by Client entity (email validation)
- **PhoneNumber**: Used by Client entity (phone validation)
- **Color**: Used by Project, Phase, Label entities (color validation + HSL/RGB conversion)

**Integration Status:** Created but not yet integrated into entities (gradual adoption)

### Value Objects vs Entities

| Aspect | Value Object | Entity |
|--------|-------------|--------|
| **Identity** | Defined by value | Has unique ID |
| **Mutability** | Immutable | Can change over time |
| **Equality** | Two with same value are equal | Two with same ID are equal |
| **Lifecycle** | No lifecycle (just created/discarded) | Tracked lifecycle (create/update/delete) |
| **Examples** | DateRange, EmailAddress, Money | Project, Client, Phase |

**Key Rule:** If you can replace it with an identical copy and nobody would notice, it's a Value Object.

---

## Domain Services (Added December 2025)

### What Are Domain Services?

**Domain Services** contain pure domain logic that doesn't naturally fit within a single entity. They are:
- **Stateless** (no internal state)
- **Pure functions** (no side effects, no dependencies)
- **Domain-focused** (no persistence, no UI)
- **Reusable** (shared across entities and orchestrators)

### Domain Services vs Application Services

| Aspect | Domain Service | Application Service (Orchestrator) |
|--------|---------------|-----------------------------------|
| **Purpose** | Pure domain algorithms | Coordinate workflows |
| **Dependencies** | None (pure logic) | Supabase, domain services, etc. |
| **Example** | Calculate recurring dates | Create project in DB |
| **Location** | `domain/domain-services/` | `services/orchestrators/` |
| **Testing** | Easy (pure functions) | Harder (mocks needed) |

### Our Domain Services

**Implemented (December 2025):**
```
src/domain/domain-services/
‚îú‚îÄ‚îÄ PhaseRecurrenceService.ts   ‚Üí Recurring phase patterns (~430 lines)
‚îú‚îÄ‚îÄ ProjectBudgetService.ts     ‚Üí Budget analysis (~400 lines)
‚îú‚îÄ‚îÄ PhaseDistributionService.ts ‚Üí Time distribution (~460 lines)
‚îî‚îÄ‚îÄ index.ts                    ‚Üí Barrel export
```

**1. PhaseRecurrenceService** - Recurring phase logic:
```typescript
// Validate recurring pattern
PhaseRecurrenceService.validateRecurringConfig(true, config, 8);

// Generate occurrence dates
PhaseRecurrenceService.generateOccurrences({
  config: { type: 'weekly', interval: 2, weeklyDayOfWeek: 1 },
  projectStartDate, projectEndDate
});
// Returns: [{ occurrenceNumber: 1, date: ... }, ...]

// Human description
PhaseRecurrenceService.getRecurrenceDescription(config);
// "Every 2 weeks on Monday"
```

**2. ProjectBudgetService** - Budget calculations:
```typescript
// Check budget status
ProjectBudgetService.checkBudgetConstraint(phases, 100);
// { isValid: true, totalAllocated: 85, remaining: 15, ... }

// Comprehensive analysis
ProjectBudgetService.analyzeBudget(phases, projectBudget);
// { recommendations: [...], isOverBudget: false, ... }

// Validate before adding
ProjectBudgetService.validatePhaseAgainstBudget(phases, 20, 100);
```

**3. PhaseDistributionService** - Time distribution:
```typescript
// Allocation statistics
PhaseDistributionService.calculateAllocationDistribution(phases);
// { min, max, avg, median, standardDeviation }

// Spacing recommendations
PhaseDistributionService.generateSpacingRecommendation(
  start, end, currentCount
);
// { recommendedDates: [...], intervalDays: 7, reasoning: "..." }

// Timeline distribution
PhaseDistributionService.calculateTimelineDistribution(
  phases, start, end
);
// [{ date, estimatedHours, phase, isDeadlineDay }, ...]
```

### Why Domain Services?

**Before Domain Services:**
- Recurring logic scattered across 3+ files
- Budget calculations duplicated
- Hard to test (mixed concerns)
- Hard to find (search multiple files)

**After Domain Services:**
- Single source of truth (~1290 lines pure logic)
- Easy to test (no dependencies)
- Clear navigation (know where to look)
- Reusable (orchestrators + rules use same service)

---

## Key Architectural Decisions

### 1. Three-Layer Documentation Model

**Domain Logic** (`/src/domain/Domain Logic.md`) defines WHAT exists (domain truth):
- "Projects have three time types: auto-estimated, planned, completed"
- "All time types coexist in the domain simultaneously"

**Rules Logic** (`/src/domain/Rules Logic.md`) defines HOW calculations work (domain rules):
- "Auto-estimate = (Remaining Hours) √∑ (Days without events)"
- "Events exclude days from auto-estimate distribution"

**Display Logic** (`/src/domain/Display Logic.md`) defines WHERE display constraints apply:
- "Timeline View shows only ONE time type per day (mutual exclusivity)"
- "Calendar View can show multiple time types (no overlap constraint)"

### 2. Domain Truth vs UI Constraints

**Example: Rule 9 (Daily Time Allocation)**

**Domain Truth** (Rules Logic):
- Auto-estimated, planned, and completed time all exist
- Calculations run regardless of display
- All time types are always available

**Display Constraint** (Display Logic):
- Timeline bars can't overlap visually
- Display only ONE type per day in Timeline View
- Same data shown differently in Calendar View

### 3. No Repository Layer

**Why:** Supabase already provides:
- Type-safe queries
- Row-level security
- Real-time subscriptions
- Query builder

Adding repositories would create:
- Wrapper methods that just delegate
- Extra abstraction with no value
- Development slowdown

**Pattern:**
```typescript
// ‚úÖ Direct Supabase (our approach)
const { data } = await supabase.from('projects').select('*');

// ‚ùå Repository wrapper (unnecessary)
const data = await projectRepository.findAll();
```

---

## Migration Path: Moving to Strict DDD

**When to Consider:**
- Team grows beyond 5-7 developers
- Domain logic leaking into orchestrators becomes painful
- Multiple clients need same backend (API reuse)
- Testing becomes difficult due to mixed concerns

### Phase 1 (Current) ‚Üí Phase 2 (Strict DDD)

**What Changes:**

### 1. Add Repository Layer (3-4 weeks)

**Current:**
```typescript
// Orchestrators call Supabase directly
await supabase.from('projects').insert(data);
```

**Strict DDD:**
```typescript
// Orchestrators call repositories
await projectRepository.create(data);

// repositories/ProjectRepository.ts
class ProjectRepository {
  async create(data: Project): Promise<Project> {
    return await supabase.from('projects').insert(data);
  }
}
```

**Effort:** 
- Create repository for each entity (9 files)
- Update all orchestrator calls
- Add repository tests

### 2. Extract Presentation Logic (2-3 weeks)

**Current:**
```typescript
// Orchestrators mix app + presentation
class ProjectOrchestrator {
  async createProject(data) {
    const dbData = this.transformForDatabase(data); // Presentation
    const project = await supabase.insert(dbData);
    return this.enrichForDisplay(project); // Presentation
  }
}
```

**Strict DDD:**
```typescript
// Application Services (pure app logic)
class ProjectApplicationService {
  async createProject(data: CreateProjectInput) {
    const validation = ProjectRules.validate(data);
    const project = await projectRepository.create(data);
    return project; // Pure entity
  }
}

// Presentation Adapters (UI prep)
class ProjectPresentationAdapter {
  static enrichForDisplay(project: Project) {
    return { ...project, displayColor: ... };
  }
}
```

**Effort:**
- Create application services layer (9 files)
- Create presentation adapters layer (new folder)
- Migrate all orchestrator logic
- Update component imports

### 3. Enforce Entity Usage (1-2 weeks)

**Current:**
```typescript
// Orchestrators work with plain data
const project = { id: '123', name: 'Test' };
```

**Strict DDD:**
```typescript
// Everything uses entity instances
const project = Project.create({ name: 'Test' });
if (!project.success) return project.errors;

const entity = project.data; // Always a Project instance
entity.isActiveOnDate(today); // Use entity methods
```

**Effort:**
- Update all orchestrators to use entities
- Update all unified services to accept entities
- Ensure entities used in components

### 4. Update Documentation (1 week)

**Effort:**
- Update `.architecture` with new layers
- Document repository patterns
- Update AI decision matrix
- Add migration notes

---

## Total Migration Estimate

**Time:** 8-12 weeks (depending on team size)

**Breakdown:**
- Week 1-4: Repository layer + tests
- Week 5-7: Extract presentation logic
- Week 8-9: Enforce entity usage everywhere
- Week 10-11: Update documentation
- Week 12: Buffer for issues

**Risk:** Medium (no breaking changes, gradual migration possible)

**Benefit:** Full code-level layer separation, easier testing, API reuse

---

## Future DDD Building Blocks (May Add Later)

These are standard DDD patterns we may adopt when needed:

### Domain Events (`domain/domain-events/`) - NOT YET IMPLEMENTED  
- **Purpose:** Things that happened in the domain
- **Example:** ProjectCreated, PhaseCompleted events
- **Status:** Not needed yet
- **Trigger:** When need to decouple side effects (notifications, integrations)

### Aggregates (`domain/aggregates/`) - NOT YET IMPLEMENTED
- **Purpose:** Cluster of entities treated as a single unit
- **Example:** Project + Phases as ProjectAggregate
- **Status:** Entities work independently
- **Trigger:** When complex transaction boundaries needed

**Note:** These can be added incrementally without major refactoring.

---

## Decision: Stay Hybrid for Now

**Reasons:**
1. **Documentation clarity achieved** - Architecture is well-documented
2. **Velocity priority** - Hybrid approach ships features faster
3. **Small team** - Current team size doesn't justify strict separation
4. **No pain points yet** - Mixing isn't causing maintenance issues
5. **Easy migration path** - Can move to strict DDD when needed
6. **Value objects added** - Getting benefits of DDD without full commitment

**Recent Progress (December 2025):**
- ‚úÖ Entities fully migrated (all contexts return entities)
- ‚úÖ Rules classes validated (intentional architecture, not redundant)
- ‚úÖ Value objects implemented (DateRange, EmailAddress, PhoneNumber, Color)
- ‚úÖ Domain services implemented (PhaseRecurrenceService, ProjectBudgetService, PhaseDistributionService)
- ‚úÖ Orchestrators aligned with entities (PhaseOrchestrator, CalendarEventOrchestrator, HolidayOrchestrator)
- ‚úÖ ~2150 lines pure domain logic extracted

**Review Triggers:**
- Team grows beyond 7 developers
- Domain logic appearing in orchestrators (violation of current rules)
- Testing becomes difficult
- Need to build separate API/mobile client
- Orchestrators become bloated with domain calculations (extract to domain-services)

---

## Future Cleanup (Optional)

**Current Reality:**
We have overlap between `services/unified/` and `domain/domain-services/`. Both work fine, but some duplication exists.

**What Should Move Eventually:**
- `UnifiedRRuleService` ‚Üí Pure RRule logic belongs in domain-services
- `UnifiedWorkHoursService` ‚Üí Pure calculations belong in domain-services
- `UnifiedProjectService` calculations ‚Üí Extract budget/timeline logic to domain-services
- `services/calculations/` ‚Üí Gradually migrate pure math to domain-services (already started with `phaseCalculations.ts`)

**What Should Stay:**
- `UnifiedTimelineService` ‚Üí UI coordination with timeline views
- `UnifiedCalendarService` ‚Üí FullCalendar integration (infrastructure)
- `UnifiedEventTransformService` ‚Üí Presentation logic (could move to `services/ui/`)
- Any service coordinating multiple concerns

**Decision Rule:**
```
Pure domain logic (calculations, validations, business rules)
  ‚Üí domain/domain-services/

UI coordination, FullCalendar, CSS classes, presentation
  ‚Üí services/unified/ or services/ui/

Cross-cutting (logging, error handling, performance)
  ‚Üí services/infrastructure/
```

**Migration Strategy:**
1. No rush - current structure works
2. When touching unified services, consider extraction
3. Use delegation pattern (like `phaseCalculations.ts` ‚Üí `PhaseRecurrenceService`)
4. Gradual, no breaking changes

**Why Document This Now:**
- Team needs clear "what goes where" rules for new code
- Prevents adding more overlap
- Sets expectations for gradual cleanup
- No pressure to refactor immediately

See `docs/sessions/services-architecture-analysis.md` for detailed analysis.

---

## Quick Reference

**Current Architecture (Hybrid DDD):**
```
Components ‚Üí Orchestrators (workflows) ‚Üí Entities + Rules + Value Objects + Domain Services + Supabase
          ‚Üí Unified Services (calcs) ‚Üí Domain Services + calculations/

Domain Layer (Pure):
  Domain Services (PhaseRecurrenceService, ProjectBudgetService, etc.)
       ‚Üë
  Value Objects (DateRange, EmailAddress, etc.)
       ‚Üë
    Entities (Project, Phase, Client)
       ‚Üë
     Rules (complex validation)
```

**Future Architecture (Strict DDD):**
```
Components ‚Üí Presentation Adapters ‚Üí Application Services ‚Üí Repositories ‚Üí Supabase
                                   ‚Üì
                            Domain Entities (everywhere)
                                   ‚Üì
                              Domain Rules
```

**Documentation (Never Changes):**
```
App Logic ‚Üí Business Logic ‚Üí View Specifications
(Pure domain truth, regardless of code approach)
```

---

**Bottom Line:** We chose clarity through documentation over purity through code. Migration to Strict DDD is straightforward when needed.
