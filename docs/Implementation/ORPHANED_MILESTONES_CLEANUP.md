# Orphaned Milestones Cleanup Issue

## Problem Summary
The Budgi project is showing unexpected auto-estimated time on the timeline (e.g., 1.33 hours on Nov 1st) despite having:
- `estimatedHours: 0` (no project budget)
- `continuous: true` (should not generate auto-estimates)
- No visible milestones in the UI

## Root Cause
Investigation revealed that Budgi has **339 orphaned milestone instances** in the database. These are numbered instances (e.g., "Sprint 1", "Sprint 2", etc.) that were auto-generated by the recurring milestone system before the recurring template was deleted.

**Key Finding:** When a recurring milestone template is deleted, the numbered instances it created remain in the database, causing unwanted milestone allocations.

### Evidence from Investigation
```
Console Log Output:
[dayEstimateCalculations] Budgi processing milestones: {count: 339, milestones: Array(339)}
[dayEstimateCalculations] Budgi Nov 1st estimates: {
  count: 1, 
  estimates: [{
    date: '01/11/2025',
    hours: 1.3333333333333333,
    source: 'milestone-allocation',  // <-- Coming from milestone, not auto-estimate
    isPlannedEvent: undefined,
    isCompletedEvent: undefined
  }]
}
```

## Required Fix

### 1. Implement Cascade Delete for Recurring Milestones

**Location:** Milestone deletion logic (likely in a delete milestone function/mutation)

**What to do:**
When a recurring milestone template (where `isRecurring === true`) is deleted, automatically delete all its numbered instances.

**Implementation:**
```typescript
// Pseudo-code for the delete milestone function
async function deleteMilestone(milestoneId: string) {
  const milestone = await fetchMilestone(milestoneId);
  
  if (milestone.isRecurring === true) {
    // This is a recurring template - delete all numbered instances
    // Numbered instances have names like "Sprint 1", "Sprint 2", etc.
    // They match the pattern: milestone.name + " " + number
    
    await deleteMilestonesWhere({
      projectId: milestone.projectId,
      name: {
        startsWith: milestone.name + " ",
        matches: /^.+ \d+$/  // Ends with space and number
      },
      isRecurring: false  // Numbered instances have isRecurring = false
    });
  }
  
  // Then delete the template itself
  await deleteMilestoneById(milestoneId);
}
```

**SQL Query for Supabase (if using direct SQL):**
```sql
-- Delete numbered instances when deleting a recurring template
DELETE FROM milestones
WHERE project_id = (SELECT project_id FROM milestones WHERE id = $1)
  AND name SIMILAR TO (SELECT name FROM milestones WHERE id = $1) || ' [0-9]+'
  AND is_recurring = false;

-- Then delete the template
DELETE FROM milestones WHERE id = $1;
```

### 2. One-Time Cleanup Script

**Immediate fix:** Create a cleanup utility to remove existing orphaned milestones.

**Location:** Create a new file `src/utils/cleanupOrphanedMilestones.ts`

```typescript
import { supabase } from '@/integrations/supabase/client';

/**
 * Removes orphaned milestone instances that no longer have a recurring template.
 * These are milestones with:
 * - isRecurring = false
 * - name ending with a space and number (e.g., "Sprint 1", "Sprint 2")
 * - no corresponding template milestone (isRecurring = true) with the base name
 */
export async function cleanupOrphanedMilestones(projectId: string) {
  try {
    // Get all milestones for the project
    const { data: allMilestones, error } = await supabase
      .from('milestones')
      .select('*')
      .eq('project_id', projectId);

    if (error) throw error;

    // Find recurring templates
    const templates = allMilestones?.filter(m => m.is_recurring === true) || [];
    const templateNames = new Set(templates.map(t => t.name));

    // Find numbered instances
    const numberedInstances = allMilestones?.filter(m => {
      if (m.is_recurring === true) return false;
      const match = m.name?.match(/^(.+) \d+$/);
      return match !== null;
    }) || [];

    // Find orphaned instances (no matching template)
    const orphanedIds = numberedInstances
      .filter(instance => {
        const match = instance.name?.match(/^(.+) \d+$/);
        if (!match) return false;
        const baseName = match[1];
        return !templateNames.has(baseName);
      })
      .map(m => m.id);

    if (orphanedIds.length === 0) {
      console.log('No orphaned milestones found');
      return { deleted: 0 };
    }

    console.log(`Found ${orphanedIds.length} orphaned milestones to delete`);

    // Delete orphaned instances
    const { error: deleteError } = await supabase
      .from('milestones')
      .delete()
      .in('id', orphanedIds);

    if (deleteError) throw deleteError;

    console.log(`Successfully deleted ${orphanedIds.length} orphaned milestones`);
    return { deleted: orphanedIds.length };
  } catch (error) {
    console.error('Error cleaning up orphaned milestones:', error);
    throw error;
  }
}
```

**Usage (can be added to a settings page or debug panel):**
```typescript
// Add a button in the project settings to run cleanup
<Button onClick={async () => {
  const result = await cleanupOrphanedMilestones(project.id);
  toast.success(`Deleted ${result.deleted} orphaned milestones`);
}}>
  Clean Up Orphaned Milestones
</Button>
```

### 3. Immediate Manual Fix (Supabase Dashboard)

For the Budgi project specifically, run this SQL in Supabase SQL Editor:

```sql
-- Preview what will be deleted
SELECT id, name, due_date, is_recurring
FROM milestones
WHERE project_id = (SELECT id FROM projects WHERE name = 'Budgi')
  AND is_recurring = false
  AND name SIMILAR TO '%[0-9]+$'
ORDER BY name;

-- After confirming, delete them
DELETE FROM milestones
WHERE project_id = (SELECT id FROM projects WHERE name = 'Budgi')
  AND is_recurring = false
  AND name SIMILAR TO '%[0-9]+$';
```

## Expected Behavior After Fix

1. **Deleting a recurring milestone template** should automatically delete all its numbered instances
2. **Budgi timeline** should show only the 202 hours of completed event time (calendar events)
3. **No auto-estimates** should appear on days without events since `estimatedHours = 0`
4. **Nov 1st** should show only event time if there's a calendar event, or nothing if there's no event

## Testing Steps

1. Create a test project with a recurring milestone
2. Verify numbered instances are generated (e.g., "Test 1", "Test 2", etc.)
3. Delete the recurring template
4. Verify all numbered instances are also deleted
5. Check that no orphaned milestones remain in the database

## Files to Modify

1. **Milestone deletion handler** - Add cascade delete logic
2. **`src/utils/cleanupOrphanedMilestones.ts`** - Create cleanup utility
3. **Project settings UI** (optional) - Add cleanup button for manual intervention

## Related Code References

- Calculation logic: `src/services/calculations/projects/dayEstimateCalculations.ts`
  - Line 377-390: Processes milestones and generates estimates
  - Line 396: Creates milestone allocations
- Timeline rendering: `src/components/timeline/TimelineBar.tsx`
  - Line 133-171: Filters milestones using HYBRID SYSTEM
  - Note: HYBRID SYSTEM already tries to filter out numbered instances when a template exists, but doesn't handle orphaned instances

## Priority
**High** - This creates confusing ghost estimates on the timeline and undermines user trust in the time tracking accuracy.
